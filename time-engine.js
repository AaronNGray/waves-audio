(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/* Generated by es6-transpiler v 0.7.14-2 *//* written in ECMAscript 6 */
/**
 * @fileoverview WAVE audio time engine base class
 * @author Norbert.Schnell@ircam.fr, Victor.Saiz@ircam.fr, Karim.Barkati@ircam.fr
 */
"use strict";

var TimeEngine = (function(){var DP$0 = Object.defineProperty;
  
  function TimeEngine() {
    /**
     * Scheduler to which the time engine has been added
     * @type {Object}
     */
    this.scheduler = null;

    /**
     * Transport to which the time engine has been added
     * @type {Object}
     */
    this.transport = null;

    /**
     * Output audio node
     * @type {Object}
     */
    this.outputNode = null;
  }DP$0(TimeEngine, "prototype", {"configurable": false, "enumerable": false, "writable": false});

  /**
   * Execute engine at next transport position
   * @param {Number} time current scheduler (audio) time
   * @param {Number} position current transport position
   * @param {Bool} whether transport runs backward (current playing direction)
   * @return {Number} next transport position (given the playing direction)
   * 
   * This function is called – more or less regulary – by the scheduler to let the engine do its work
   * synchronized to the scheduler time.
   */
  TimeEngine.prototype.executeSchedulerTime = function(time, position) {var reverse = arguments[2];if(reverse === void 0)reverse = false;
    return Infinity;
  }

  /**
   * Request time engine rescheduling (called by engine itself)
   * @param {Number} time new next scheduler time or transport position
   */
  TimeEngine.prototype.rescheduleEngine = function(time) {
    if(this.scheduler)
      this.scheduler.reschedule(this, time);
  }

  /**
   * Synchronize time engine to transport position
   * @param {Number} time current scheduler (audio) time
   * @param {Number} position transport position to synchronize to
   * @param {Bool} whether transport runs backward (current playing direction)
   * @return {Number} next transport position (given the playing direction)
   *
   * This function allows the engine for synchronizing (seeking) to the current transport position
   * and to return the position of the next transport position of the engine.
   * Engines that return Infinity or -Infinity are not called anymore until they call resyncEngine()
   * with a valid transport position.
   */
  TimeEngine.prototype.syncTransportPosition = function(time, position) {var reverse = arguments[2];if(reverse === void 0)reverse = false;
    return Infinity;
  }

  /**
   * Execute engine at next transport position
   * @param {Number} time current scheduler (audio) time
   * @param {Number} position current transport position
   * @param {Bool} whether transport runs backward (current playing direction)
   * @return {Number} next transport position (given the playing direction)
   *
   * This function is called – more or less regulary – by the transport to let the engine do its work
   * aligned to the transport position.
   */
  TimeEngine.prototype.executeTransportPosition = function(time, position) {var reverse = arguments[2];if(reverse === void 0)reverse = false;
    return Infinity;
  }

  /**
   * Request time engine to be resynchronized to the current transport position (called by engine itself)
   *
   * This function will result in syncTransportPosition() being called with the current transport position
   * to adjust the engines priority in the transport queue.
   */
  TimeEngine.prototype.resyncEngine = function() {
    if(this.transport)
      this.transport.resync(this);
  }

  /**
   * Connect audio node
   * @param {Object} target audio node
   */
  TimeEngine.prototype.connect = function(target) {
    this.outputNode.connect(target);
    return this;
  }

  /**
   * Disconnect audio node
   * @param {Number} connection connection to be disconnected
   */
  TimeEngine.prototype.disconnect = function(connection) {
    this.outputNode.disconnect(connection);
    return this;
  }
;return TimeEngine;})();

module.exports = TimeEngine;
},{}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2huZWxsL0RldmVsb3BtZW50L3dlYi9taXNjL2d1bHBCcm93RXJzeTYvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi9Vc2Vycy9zY2huZWxsL0RldmVsb3BtZW50L3dlYi93YXZlL2xpYi9naXRodWIvYXVkaW8vdGltZS1lbmdpbmUvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qIEdlbmVyYXRlZCBieSBlczYtdHJhbnNwaWxlciB2IDAuNy4xNC0yICovLyogd3JpdHRlbiBpbiBFQ01Bc2NyaXB0IDYgKi9cbi8qKlxuICogQGZpbGVvdmVydmlldyBXQVZFIGF1ZGlvIHRpbWUgZW5naW5lIGJhc2UgY2xhc3NcbiAqIEBhdXRob3IgTm9yYmVydC5TY2huZWxsQGlyY2FtLmZyLCBWaWN0b3IuU2FpekBpcmNhbS5mciwgS2FyaW0uQmFya2F0aUBpcmNhbS5mclxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFRpbWVFbmdpbmUgPSAoZnVuY3Rpb24oKXt2YXIgRFAkMCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbiAgXG4gIGZ1bmN0aW9uIFRpbWVFbmdpbmUoKSB7XG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVyIHRvIHdoaWNoIHRoZSB0aW1lIGVuZ2luZSBoYXMgYmVlbiBhZGRlZFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5zY2hlZHVsZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVHJhbnNwb3J0IHRvIHdoaWNoIHRoZSB0aW1lIGVuZ2luZSBoYXMgYmVlbiBhZGRlZFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy50cmFuc3BvcnQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogT3V0cHV0IGF1ZGlvIG5vZGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMub3V0cHV0Tm9kZSA9IG51bGw7XG4gIH1EUCQwKFRpbWVFbmdpbmUsIFwicHJvdG90eXBlXCIsIHtcImNvbmZpZ3VyYWJsZVwiOiBmYWxzZSwgXCJlbnVtZXJhYmxlXCI6IGZhbHNlLCBcIndyaXRhYmxlXCI6IGZhbHNlfSk7XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgZW5naW5lIGF0IG5leHQgdHJhbnNwb3J0IHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIGN1cnJlbnQgc2NoZWR1bGVyIChhdWRpbykgdGltZVxuICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gY3VycmVudCB0cmFuc3BvcnQgcG9zaXRpb25cbiAgICogQHBhcmFtIHtCb29sfSB3aGV0aGVyIHRyYW5zcG9ydCBydW5zIGJhY2t3YXJkIChjdXJyZW50IHBsYXlpbmcgZGlyZWN0aW9uKVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IG5leHQgdHJhbnNwb3J0IHBvc2l0aW9uIChnaXZlbiB0aGUgcGxheWluZyBkaXJlY3Rpb24pXG4gICAqIFxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCDigJPCoG1vcmUgb3IgbGVzcyByZWd1bGFyeSDigJPCoGJ5IHRoZSBzY2hlZHVsZXIgdG8gbGV0IHRoZSBlbmdpbmUgZG8gaXRzIHdvcmtcbiAgICogc3luY2hyb25pemVkIHRvIHRoZSBzY2hlZHVsZXIgdGltZS5cbiAgICovXG4gIFRpbWVFbmdpbmUucHJvdG90eXBlLmV4ZWN1dGVTY2hlZHVsZXJUaW1lID0gZnVuY3Rpb24odGltZSwgcG9zaXRpb24pIHt2YXIgcmV2ZXJzZSA9IGFyZ3VtZW50c1syXTtpZihyZXZlcnNlID09PSB2b2lkIDApcmV2ZXJzZSA9IGZhbHNlO1xuICAgIHJldHVybiBJbmZpbml0eTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRpbWUgZW5naW5lIHJlc2NoZWR1bGluZyAoY2FsbGVkIGJ5IGVuZ2luZSBpdHNlbGYpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIG5ldyBuZXh0IHNjaGVkdWxlciB0aW1lIG9yIHRyYW5zcG9ydCBwb3NpdGlvblxuICAgKi9cbiAgVGltZUVuZ2luZS5wcm90b3R5cGUucmVzY2hlZHVsZUVuZ2luZSA9IGZ1bmN0aW9uKHRpbWUpIHtcbiAgICBpZih0aGlzLnNjaGVkdWxlcilcbiAgICAgIHRoaXMuc2NoZWR1bGVyLnJlc2NoZWR1bGUodGhpcywgdGltZSk7XG4gIH1cblxuICAvKipcbiAgICogU3luY2hyb25pemUgdGltZSBlbmdpbmUgdG8gdHJhbnNwb3J0IHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIGN1cnJlbnQgc2NoZWR1bGVyIChhdWRpbykgdGltZVxuICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gdHJhbnNwb3J0IHBvc2l0aW9uIHRvIHN5bmNocm9uaXplIHRvXG4gICAqIEBwYXJhbSB7Qm9vbH0gd2hldGhlciB0cmFuc3BvcnQgcnVucyBiYWNrd2FyZCAoY3VycmVudCBwbGF5aW5nIGRpcmVjdGlvbilcbiAgICogQHJldHVybiB7TnVtYmVyfSBuZXh0IHRyYW5zcG9ydCBwb3NpdGlvbiAoZ2l2ZW4gdGhlIHBsYXlpbmcgZGlyZWN0aW9uKVxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFsbG93cyB0aGUgZW5naW5lIGZvciBzeW5jaHJvbml6aW5nIChzZWVraW5nKSB0byB0aGUgY3VycmVudCB0cmFuc3BvcnQgcG9zaXRpb25cbiAgICogYW5kIHRvIHJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIG5leHQgdHJhbnNwb3J0IHBvc2l0aW9uIG9mIHRoZSBlbmdpbmUuXG4gICAqIEVuZ2luZXMgdGhhdCByZXR1cm4gSW5maW5pdHkgb3IgLUluZmluaXR5IGFyZSBub3QgY2FsbGVkIGFueW1vcmUgdW50aWwgdGhleSBjYWxsIHJlc3luY0VuZ2luZSgpXG4gICAqIHdpdGggYSB2YWxpZCB0cmFuc3BvcnQgcG9zaXRpb24uXG4gICAqL1xuICBUaW1lRW5naW5lLnByb3RvdHlwZS5zeW5jVHJhbnNwb3J0UG9zaXRpb24gPSBmdW5jdGlvbih0aW1lLCBwb3NpdGlvbikge3ZhciByZXZlcnNlID0gYXJndW1lbnRzWzJdO2lmKHJldmVyc2UgPT09IHZvaWQgMClyZXZlcnNlID0gZmFsc2U7XG4gICAgcmV0dXJuIEluZmluaXR5O1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgZW5naW5lIGF0IG5leHQgdHJhbnNwb3J0IHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIGN1cnJlbnQgc2NoZWR1bGVyIChhdWRpbykgdGltZVxuICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gY3VycmVudCB0cmFuc3BvcnQgcG9zaXRpb25cbiAgICogQHBhcmFtIHtCb29sfSB3aGV0aGVyIHRyYW5zcG9ydCBydW5zIGJhY2t3YXJkIChjdXJyZW50IHBsYXlpbmcgZGlyZWN0aW9uKVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IG5leHQgdHJhbnNwb3J0IHBvc2l0aW9uIChnaXZlbiB0aGUgcGxheWluZyBkaXJlY3Rpb24pXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIOKAk8KgbW9yZSBvciBsZXNzIHJlZ3VsYXJ5IOKAk8KgYnkgdGhlIHRyYW5zcG9ydCB0byBsZXQgdGhlIGVuZ2luZSBkbyBpdHMgd29ya1xuICAgKiBhbGlnbmVkIHRvIHRoZSB0cmFuc3BvcnQgcG9zaXRpb24uXG4gICAqL1xuICBUaW1lRW5naW5lLnByb3RvdHlwZS5leGVjdXRlVHJhbnNwb3J0UG9zaXRpb24gPSBmdW5jdGlvbih0aW1lLCBwb3NpdGlvbikge3ZhciByZXZlcnNlID0gYXJndW1lbnRzWzJdO2lmKHJldmVyc2UgPT09IHZvaWQgMClyZXZlcnNlID0gZmFsc2U7XG4gICAgcmV0dXJuIEluZmluaXR5O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdGltZSBlbmdpbmUgdG8gYmUgcmVzeW5jaHJvbml6ZWQgdG8gdGhlIGN1cnJlbnQgdHJhbnNwb3J0IHBvc2l0aW9uIChjYWxsZWQgYnkgZW5naW5lIGl0c2VsZilcbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIHJlc3VsdCBpbiBzeW5jVHJhbnNwb3J0UG9zaXRpb24oKSBiZWluZyBjYWxsZWQgd2l0aCB0aGUgY3VycmVudCB0cmFuc3BvcnQgcG9zaXRpb25cbiAgICogdG8gYWRqdXN0IHRoZSBlbmdpbmVzIHByaW9yaXR5IGluIHRoZSB0cmFuc3BvcnQgcXVldWUuXG4gICAqL1xuICBUaW1lRW5naW5lLnByb3RvdHlwZS5yZXN5bmNFbmdpbmUgPSBmdW5jdGlvbigpIHtcbiAgICBpZih0aGlzLnRyYW5zcG9ydClcbiAgICAgIHRoaXMudHJhbnNwb3J0LnJlc3luYyh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25uZWN0IGF1ZGlvIG5vZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBhdWRpbyBub2RlXG4gICAqL1xuICBUaW1lRW5naW5lLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgdGhpcy5vdXRwdXROb2RlLmNvbm5lY3QodGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNjb25uZWN0IGF1ZGlvIG5vZGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbm5lY3Rpb24gY29ubmVjdGlvbiB0byBiZSBkaXNjb25uZWN0ZWRcbiAgICovXG4gIFRpbWVFbmdpbmUucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbihjb25uZWN0aW9uKSB7XG4gICAgdGhpcy5vdXRwdXROb2RlLmRpc2Nvbm5lY3QoY29ubmVjdGlvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbjtyZXR1cm4gVGltZUVuZ2luZTt9KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVFbmdpbmU7Il19
