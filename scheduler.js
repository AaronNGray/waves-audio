(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/* Generated by es6-transpiler v 0.7.14-2 *//**
 * @fileoverview WAVE audio library element: an event queue manager.
 * @author Karim.Barkati@ircam.fr, Norbert.Schnell@ircam.fr, Victor.Saiz@ircam.fr
 * @version 0.3.2
 * @description An event is made of an object (such as an engine) and a value (such as a time or a position).
 */

'use strict';

var EventQueue = (function(){var DP$0 = Object.defineProperty;
  
  function EventQueue() {
    if (!(this instanceof EventQueue)) throw new Error('You seem to have forgotten the new operatorâ€¦ shame on you!');

    this.eventList = [];
    this.name = require('./package.json').name;
    
    this.__isBackward = false;
  }Object.defineProperties(EventQueue.prototype, {length: {"get": length$get$0, "configurable": true, "enumerable": true}});DP$0(EventQueue, "prototype", {"configurable": false, "enumerable": false, "writable": false});

  /**
   * Compare two events based on their value only.
   * @private
   * @param {Event} a
   * @param {Event} b
   */
  EventQueue.prototype.__compare = function(a, b) {
    return a[1] - b[1];
  }

  /**
   * Compare two events based on their value only, in reverse order.
   * @private
   * @param {Event} a
   * @param {Event} b
   */
  EventQueue.prototype.__reverseCompare = function(a, b) {
    return b[1] - a[1];
  }

  /**
   * Get the index of an object in the event list.
   * @private
   */
  EventQueue.prototype.__indexOf = function(object) {
    var i = null;
    for (i = 0; i < this.__eventList.length; i++) {
      if (object === this.__eventList[i][0]) {
        return i;
      }
    }
    return -1;
  }

  // this.length helper
  function length$get$0() {
    return this.__eventList.length;
  }

  /**
   * Insert an event (an ordered pair [object, value]) into eventList.
   * @public
   * @param {Object} object reference
   * @param {Float} value for scheduling or sequencing, ie either time or position value
   */
  EventQueue.prototype.insert = function(object, value) {
    this.pushEvent(object, value);
    this.sort();
  }

  /**
   * Push an event (an ordered pair [object, value]) into eventList without sorting.
   * @public
   * @param {Object} object reference
   * @param {Float} value for scheduling or sequencing, ie either time or position value
   */
  EventQueue.prototype.pushEvent = function(object, value) {
    this.__eventList.push([object, value]);
  }

  /**
   * Remove an event from the event list.
   * @public
   * @chainable
   * @param {Object} object of the event to remove (1 to 1 hypothesis)
   */
  EventQueue.prototype.remove = function(object) {
    if (object) {
      // Search for the index of the object in the list (not the full event pair).
      var index = this.__indexOf(object);
      if (index < 0) {
        throw new Error("remove(): no object");
      } else {
        this.__eventList.splice(index, 1);
      }
      return this; // for chainability
    } else {
      throw new ReferenceError("remove(): no object");
    }
  }

  /**
   * Move an event (an ordered pair [object, value]) into the event list.
   * @public
   * @param {Object} object reference
   * @param {Float} value for scheduling or sequencing, i.e. either time or position value
   * @todo Optimize algorithm: at least, test if moving is necessary?
   */
  EventQueue.prototype.move = function(object, value) {
    this.remove(object);
    this.insert(object, value);
  }

  /**
   * Move the first event of the event list only if needed.
   * @public
   * @param {Object} object reference
   * @param {Float} value for scheduling or sequencing, ie either time or position value
   */
  EventQueue.prototype.moveFirstEvent = function(object, value) {
    if (this.__isBackward) {
      if (value > this.getValueOfIndex(1)) {
        this.__eventList[0][1] = value;
      } else {
        this.__eventList.shift();
        this.insert(object, value);
      }
    } else {
      if (value <= this.getValueOfIndex(1)) {
        this.__eventList[0][1] = value;
      } else {
        this.__eventList.shift();
        this.insert(object, value);
      }
    }
  }

  /**
   * Get first event from the event list.
   * @public
   */
  EventQueue.prototype.getFirstEvent = function() {
    return this.__eventList[0];
  }

  /**
   * Get object of first event from the event list.
   * @public
   */
  EventQueue.prototype.getFirstObject = function() {
    return this.__eventList[0][0];
  }

  /**
   * Get value of first event from the event list (either time or position).
   * @public
   */
  EventQueue.prototype.getFirstValue = function() {
    return this.__eventList[0][1];
  }

  /**
   * Get value of the specified event from the event list (either time or position).
   * @public
   */
  EventQueue.prototype.getValueOfIndex = function(index) {
    if (this.__eventList[index]) {
      return this.__eventList[index][1];
    } else {
      return Infinity;
    }
  }

  /**
   * Flush the event list.
   * @public
   */
  EventQueue.prototype.flush = function() {
    this.__eventList = [];
  }


  /**
   * Sort the whole event list.
   * @public
   */
  EventQueue.prototype.sort = function() {
    if (this.__isBackward) {
      this.__eventList.sort(this.__reverseCompare);
    } else {
      this.__eventList.sort(this.__compare);
    }
  }

;return EventQueue;})();

module.exports = EventQueue;
},{"./package.json":2}],2:[function(require,module,exports){
module.exports={
  "name": "event-queue",
  "version": "0.2.0",
  "description": "WAVE audio library module for an event queue",
  "main": "index.js",
  "exports": "createEventQueue",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "Karim Barkati",
  "authors": [
    "Karim Barkati",
    "Norbert Schnell",
    "Victor Saiz"
  ],
  "license": "BSD-3-Clause",
  "repository": {
    "type": "git",
    "url": "http://github.com/Ircam-RnD/event-queue.git"
  },
  "devDependencies": {
    "module-boilerplate": "git://github.com/Ircam-RnD/module-boilerplate.git#master",
    "fs-utils" : "0.4.3",
    "browserify": "~4.1.2",
    "mocha": "~1.17.1",
    "chai": "~1.9.0",
    "blanket": "~1.1.6",
    "gulp": "~3.8.2"
  }
}
},{}],3:[function(require,module,exports){
/* Generated by es6-transpiler v 0.7.14-2 */
/**
 * @fileoverview WAVE audio library element: the main audio scheduler of the library,
 * as a singleton in the global variable 'wako'.
 * @author Karim.Barkati@ircam.fr, Norbert.Schnell@ircam.fr, Victor.Saiz@ircam.fr
 * @version 5.1.0
 */

'use strict';

// Ensure there is a globally available "audioContext" instance of the web audio AudioContext.
window.audioContext = window.audioContext || new AudioContext();

var Scheduler = require("../scheduler");

var MainScheduler = (function(){var DP$0 = Object.defineProperty;

  function MainScheduler() {

    this.name = "wako.scheduler"
    // How frequently to call scheduling function (sec).
    this.schedulingPeriod =  0.025;
    // How far ahead to schedule events (sec), should be greater than schedulingPeriod.
    this.scheduleAheadTime = 0.1; 
    this.scheduler = new Scheduler();

    this.timerID = null;

    this.scheduler.setParent(this, this.onRunningStatusChange);
    return this;
  }DP$0(MainScheduler, "prototype", {"configurable": false, "enumerable": false, "writable": false});

  /**
   * React to running status change of the main scheduler through this callback.
   * @private
   */
  MainScheduler.prototype.onRunningStatusChange = function(bool) {
    console.log("onRunningStatusChange (mainScheduler)", bool);
    if (bool) {
      this.parent.start();
    } else {
      this.parent.stop();
    }
  }

  /**
   * Coarse-grained scheduling of audio events.
   * @public
   */
  MainScheduler.prototype.start = function() {
    var that = this; // for the setTimeout closure, faster than a bind()
    var nextEventTime = Infinity;

    // While there are events that will need to be played before the next interval, 
    // schedule them and advance the time pointer.
    nextEventTime = this.scheduler.getNextTime();
    while (nextEventTime <= audioContext.currentTime + this.scheduleAheadTime) {
      // nextEventTime = this.scheduler.makeEventAndReturnNextTime();
      this.scheduler.makeNextEvent();
      nextEventTime = this.scheduler.getNextTime();
    }
    // Store the setTimeout ID to allow removing.
    this.timerID = setTimeout(function() {
      that.start();
    }, that.schedulingPeriod * 1000);
  }

  /**
   * Stop the scheduling loop.
   * @public
   */
  MainScheduler.prototype.stop = function() {
    clearTimeout(this.timerID);
  }

  /**
   * Forward the add() method to the internal scheduler.
   * @public
   * @chainable
   */
  MainScheduler.prototype.add = function(object) {
    this.scheduler.add(object);
    return this;
  }

  /**
   * Forward the remove() method to the internal scheduler.
   * @public
   * @chainable
   */
  MainScheduler.prototype.remove = function(object) {
    this.scheduler.remove(object);
    return this;
  }

  /**
   * Get scheduling period.
   * @public
   */
  MainScheduler.prototype.getSchedulingPeriod = function() {
    return this.schedulingPeriod;
  }

  /**
   * Get current time from the Web Audio context.
   * @public
   */
  MainScheduler.prototype.getCurrentTime = function() {
    return audioContext.currentTime;
  }

;return MainScheduler;})();

// Ensure there is a globally available "wako" instance of the WAVE's global name-space.
window.wako = window.wako || {};

// Provide wako with a MainScheduler singleton, only if not already there.
wako.scheduler = wako.scheduler || new MainScheduler();
},{"../scheduler":4}],4:[function(require,module,exports){
/* Generated by es6-transpiler v 0.7.14-2 */
/**
 * @fileoverview WAVE audio library element: a web audio scheduler, without time loop.
 * @author Karim.Barkati@ircam.fr, Norbert.Schnell@ircam.fr, Victor.Saiz@ircam.fr
 * @version 4.1.0
 */

'use strict';

var EventQueue = require("../event-queue");

// Make a global instance of the wako.scheduler available
require("../main-scheduler");

var Scheduler = (function(){var DP$0 = Object.defineProperty;

  function Scheduler(optName) {

    if (!this || this === window)
      throw new SyntaxError("You seem to have forgotten the new operator; Shame on you!");

    this.name = optName || "Scheduler";
    this.isRunning = false;    
    this.eventQueue = null;
    this.nextEventTime = Infinity
    this.schedulablesList = []
    this.parent = null
    // required method, from the parent
    this.runningStatusChangeCallback = null;
    this.eventQueue = new EventQueue();

    return this;
  }DP$0(Scheduler, "prototype", {"configurable": false, "enumerable": false, "writable": false});

  /**
   * Schedule a schedulable object and add it to the scheduling list.
   * @public
   * @chainable
   */
  Scheduler.prototype.add = function(object) {
    object.scheduler = this;
    var length = this.schedulablesList.push(object);
    var index = length - 1;
    var name = object.name ? object.name : object.schedulingID;
    console.log("add():", this.name, "scheduling element #" + index + ' \"' + name + '\"');
    if (!this.isRunning) {
      // this.resetAll();
    }
    return this;
  }

  /**
   * Unschedule a schedulable object and remove it from the scheduling list.
   * @public
   * @chainable
   */
  Scheduler.prototype.remove = function(object) {
    // Search for the object in the scheduling list.
    var index = this.schedulablesList.indexOf(object);

    if (index < 0) {
      throw new Error("remove(): object not found," + object);
    } else {
      this.schedulablesList.splice(index, 1);
      console.log("Unscheduling element #" + index, object.name ? '\"' + object.name + '\"' : "", object.schedulingID);
      // When the scheduling list is empty, stop scheduling.
      if (this.schedulablesList.length <= 0) {
        this.stop();
      }
    }
    return this;
  }

  /**
   * Start scheduling.
   * @private
   */
  Scheduler.prototype.start = function() {
    if (!this.isRunning) {
      this.isRunning = true;
      console.log("Scheduling on", "(" + this.name + ")");
      this.runningStatusChangeCallback(this.isRunning);
    }
  }

  /**
   * Stop scheduling.
   * @private
   */
  Scheduler.prototype.stop = function() {
    this.isRunning = false;
    console.log("Scheduling off (" + this.name + ")");
    this.runningStatusChangeCallback(this.isRunning);
  }

  /**
   * Reset all schedulables objects of this scheduler.
   * @public
   */
  Scheduler.prototype.reset = function() {
    this.eventQueue.flush();
    this.insertAll();
  }

  /**
   * Push all events into the event queue and sort it afterward.
   * @private
   */
  Scheduler.prototype.insertAll = function() {
    var time = null;
    var element = null;
    // console.log("schedulablesList: ", this.schedulablesList);
    for (var i = this.schedulablesList.length - 1; i >= 0; i--) {
      element = this.schedulablesList[i];
      time = element.resetAndReturnNextTime(this.getCurrentTime());
      this.eventQueue.pushEvent(element, time);
    }
    this.eventQueue.sort();
  }

  /**
   * Insert an event into the event queue.
   * @public
   */
  Scheduler.prototype.insertEvent = function(object, time) {
    if (time !== Infinity) {
      this.eventQueue.Insert(object, time);
    }
  }

  /**
   * Get current time from wako.scheduler.
   * @public
   */
  Scheduler.prototype.getCurrentTime = function() {
    return wako.scheduler.getCurrentTime();
  }

  /**
   * Update next scheduling time of a scheduled object.
   * @private
   * @param {Object} object reference
   * @param {Float} new scheduling time of its next event; "Infinity" means "remove from scheduling"
   */
  Scheduler.prototype.updateNextTime = function(object, time) {
    if (time === Infinity) {
      this.eventQueue.remove(object);
      // If the queue is empty, stop scheduling.
      if (this.eventQueue.length <= 0) {
        this.stop();
      }
    } else {
      if (this.eventQueue.indexOf(object) < 0) {
        this.eventQueue.insert(object, time);
      } else {
        this.eventQueue.move(object, time);
      }
      this.start();
    }
  }

  /**
   * Set parent and status change callback.
   * @private
   * @param {Object} parent The parent of a scheduler has to be set.
   * @param {Function} callback This required callback triggers the parent,
   * with a boolean on running status change.
   */
  Scheduler.prototype.setParent = function(object, callback) {
    this.parent = object;
    this.runningStatusChangeCallback = callback;
  }


  /////////////////////////////
  /// Transporting methods ///
  /////////////////////////////

  /**
   * Call the event making method of the first schedulable object,
   * and then update the first event of the queue.
   * @public
   */
  Scheduler.prototype.makeNextEvent = function() {
    var engine = this.eventQueue.getFirstObject();
    this.nextEventTime = engine.makeEventAndReturnNextTime();
    this.eventQueue.moveFirstEvent(engine, this.nextEventTime);
  }

  /**
   * Get next event time by querying it in the event queue.
   * @public
   */
  Scheduler.prototype.getNextTime = function() {
    if (this.schedulablesList.length > 0) {
      this.nextEventTime = this.eventQueue.getFirstValue();
      return this.nextEventTime;
    } else {
      return Infinity;
    }
  }

;return Scheduler;})();

module.exports = Scheduler;
},{"../event-queue":1,"../main-scheduler":3}]},{},[4])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Wb2x1bWVzL0hvbWUvRG9jdW1lbnRzL1dBVkUvZ3VscEJyb3dFcnN5Ni9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwiL1ZvbHVtZXMvSG9tZS9Eb2N1bWVudHMvd2F2ZS9yZXBvL2xpYi9naXRodWIvYXVkaW8vZXZlbnQtcXVldWUvaW5kZXguanMiLCIvVm9sdW1lcy9Ib21lL0RvY3VtZW50cy93YXZlL3JlcG8vbGliL2dpdGh1Yi9hdWRpby9ldmVudC1xdWV1ZS9wYWNrYWdlLmpzb24iLCIvVm9sdW1lcy9Ib21lL0RvY3VtZW50cy93YXZlL3JlcG8vbGliL2dpdGh1Yi9hdWRpby9tYWluLXNjaGVkdWxlci9pbmRleC5qcyIsIi9Wb2x1bWVzL0hvbWUvRG9jdW1lbnRzL3dhdmUvcmVwby9saWIvZ2l0aHViL2F1ZGlvL3NjaGVkdWxlci9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qIEdlbmVyYXRlZCBieSBlczYtdHJhbnNwaWxlciB2IDAuNy4xNC0yICovLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFdBVkUgYXVkaW8gbGlicmFyeSBlbGVtZW50OiBhbiBldmVudCBxdWV1ZSBtYW5hZ2VyLlxuICogQGF1dGhvciBLYXJpbS5CYXJrYXRpQGlyY2FtLmZyLCBOb3JiZXJ0LlNjaG5lbGxAaXJjYW0uZnIsIFZpY3Rvci5TYWl6QGlyY2FtLmZyXG4gKiBAdmVyc2lvbiAwLjMuMlxuICogQGRlc2NyaXB0aW9uIEFuIGV2ZW50IGlzIG1hZGUgb2YgYW4gb2JqZWN0IChzdWNoIGFzIGFuIGVuZ2luZSkgYW5kIGEgdmFsdWUgKHN1Y2ggYXMgYSB0aW1lIG9yIGEgcG9zaXRpb24pLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50UXVldWUgPSAoZnVuY3Rpb24oKXt2YXIgRFAkMCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbiAgXG4gIGZ1bmN0aW9uIEV2ZW50UXVldWUoKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEV2ZW50UXVldWUpKSB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBzZWVtIHRvIGhhdmUgZm9yZ290dGVuIHRoZSBuZXcgb3BlcmF0b3LigKYgc2hhbWUgb24geW91IScpO1xuXG4gICAgdGhpcy5ldmVudExpc3QgPSBbXTtcbiAgICB0aGlzLm5hbWUgPSByZXF1aXJlKCcuL3BhY2thZ2UuanNvbicpLm5hbWU7XG4gICAgXG4gICAgdGhpcy5fX2lzQmFja3dhcmQgPSBmYWxzZTtcbiAgfU9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEV2ZW50UXVldWUucHJvdG90eXBlLCB7bGVuZ3RoOiB7XCJnZXRcIjogbGVuZ3RoJGdldCQwLCBcImNvbmZpZ3VyYWJsZVwiOiB0cnVlLCBcImVudW1lcmFibGVcIjogdHJ1ZX19KTtEUCQwKEV2ZW50UXVldWUsIFwicHJvdG90eXBlXCIsIHtcImNvbmZpZ3VyYWJsZVwiOiBmYWxzZSwgXCJlbnVtZXJhYmxlXCI6IGZhbHNlLCBcIndyaXRhYmxlXCI6IGZhbHNlfSk7XG5cbiAgLyoqXG4gICAqIENvbXBhcmUgdHdvIGV2ZW50cyBiYXNlZCBvbiB0aGVpciB2YWx1ZSBvbmx5LlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBhXG4gICAqIEBwYXJhbSB7RXZlbnR9IGJcbiAgICovXG4gIEV2ZW50UXVldWUucHJvdG90eXBlLl9fY29tcGFyZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYVsxXSAtIGJbMV07XG4gIH1cblxuICAvKipcbiAgICogQ29tcGFyZSB0d28gZXZlbnRzIGJhc2VkIG9uIHRoZWlyIHZhbHVlIG9ubHksIGluIHJldmVyc2Ugb3JkZXIuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGFcbiAgICogQHBhcmFtIHtFdmVudH0gYlxuICAgKi9cbiAgRXZlbnRRdWV1ZS5wcm90b3R5cGUuX19yZXZlcnNlQ29tcGFyZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYlsxXSAtIGFbMV07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbmRleCBvZiBhbiBvYmplY3QgaW4gdGhlIGV2ZW50IGxpc3QuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBFdmVudFF1ZXVlLnByb3RvdHlwZS5fX2luZGV4T2YgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgaSA9IG51bGw7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuX19ldmVudExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChvYmplY3QgPT09IHRoaXMuX19ldmVudExpc3RbaV1bMF0pIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8vIHRoaXMubGVuZ3RoIGhlbHBlclxuICBmdW5jdGlvbiBsZW5ndGgkZ2V0JDAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19ldmVudExpc3QubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydCBhbiBldmVudCAoYW4gb3JkZXJlZCBwYWlyIFtvYmplY3QsIHZhbHVlXSkgaW50byBldmVudExpc3QuXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCByZWZlcmVuY2VcbiAgICogQHBhcmFtIHtGbG9hdH0gdmFsdWUgZm9yIHNjaGVkdWxpbmcgb3Igc2VxdWVuY2luZywgaWUgZWl0aGVyIHRpbWUgb3IgcG9zaXRpb24gdmFsdWVcbiAgICovXG4gIEV2ZW50UXVldWUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKG9iamVjdCwgdmFsdWUpIHtcbiAgICB0aGlzLnB1c2hFdmVudChvYmplY3QsIHZhbHVlKTtcbiAgICB0aGlzLnNvcnQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdXNoIGFuIGV2ZW50IChhbiBvcmRlcmVkIHBhaXIgW29iamVjdCwgdmFsdWVdKSBpbnRvIGV2ZW50TGlzdCB3aXRob3V0IHNvcnRpbmcuXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCByZWZlcmVuY2VcbiAgICogQHBhcmFtIHtGbG9hdH0gdmFsdWUgZm9yIHNjaGVkdWxpbmcgb3Igc2VxdWVuY2luZywgaWUgZWl0aGVyIHRpbWUgb3IgcG9zaXRpb24gdmFsdWVcbiAgICovXG4gIEV2ZW50UXVldWUucHJvdG90eXBlLnB1c2hFdmVudCA9IGZ1bmN0aW9uKG9iamVjdCwgdmFsdWUpIHtcbiAgICB0aGlzLl9fZXZlbnRMaXN0LnB1c2goW29iamVjdCwgdmFsdWVdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZXZlbnQgZnJvbSB0aGUgZXZlbnQgbGlzdC5cbiAgICogQHB1YmxpY1xuICAgKiBAY2hhaW5hYmxlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3Qgb2YgdGhlIGV2ZW50IHRvIHJlbW92ZSAoMSB0byAxIGh5cG90aGVzaXMpXG4gICAqL1xuICBFdmVudFF1ZXVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0KSB7XG4gICAgICAvLyBTZWFyY2ggZm9yIHRoZSBpbmRleCBvZiB0aGUgb2JqZWN0IGluIHRoZSBsaXN0IChub3QgdGhlIGZ1bGwgZXZlbnQgcGFpcikuXG4gICAgICB2YXIgaW5kZXggPSB0aGlzLl9faW5kZXhPZihvYmplY3QpO1xuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZW1vdmUoKTogbm8gb2JqZWN0XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fX2V2ZW50TGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmFiaWxpdHlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwicmVtb3ZlKCk6IG5vIG9iamVjdFwiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTW92ZSBhbiBldmVudCAoYW4gb3JkZXJlZCBwYWlyIFtvYmplY3QsIHZhbHVlXSkgaW50byB0aGUgZXZlbnQgbGlzdC5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHJlZmVyZW5jZVxuICAgKiBAcGFyYW0ge0Zsb2F0fSB2YWx1ZSBmb3Igc2NoZWR1bGluZyBvciBzZXF1ZW5jaW5nLCBpLmUuIGVpdGhlciB0aW1lIG9yIHBvc2l0aW9uIHZhbHVlXG4gICAqIEB0b2RvIE9wdGltaXplIGFsZ29yaXRobTogYXQgbGVhc3QsIHRlc3QgaWYgbW92aW5nIGlzIG5lY2Vzc2FyeT9cbiAgICovXG4gIEV2ZW50UXVldWUucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbihvYmplY3QsIHZhbHVlKSB7XG4gICAgdGhpcy5yZW1vdmUob2JqZWN0KTtcbiAgICB0aGlzLmluc2VydChvYmplY3QsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIHRoZSBmaXJzdCBldmVudCBvZiB0aGUgZXZlbnQgbGlzdCBvbmx5IGlmIG5lZWRlZC5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHJlZmVyZW5jZVxuICAgKiBAcGFyYW0ge0Zsb2F0fSB2YWx1ZSBmb3Igc2NoZWR1bGluZyBvciBzZXF1ZW5jaW5nLCBpZSBlaXRoZXIgdGltZSBvciBwb3NpdGlvbiB2YWx1ZVxuICAgKi9cbiAgRXZlbnRRdWV1ZS5wcm90b3R5cGUubW92ZUZpcnN0RXZlbnQgPSBmdW5jdGlvbihvYmplY3QsIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX19pc0JhY2t3YXJkKSB7XG4gICAgICBpZiAodmFsdWUgPiB0aGlzLmdldFZhbHVlT2ZJbmRleCgxKSkge1xuICAgICAgICB0aGlzLl9fZXZlbnRMaXN0WzBdWzFdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9fZXZlbnRMaXN0LnNoaWZ0KCk7XG4gICAgICAgIHRoaXMuaW5zZXJ0KG9iamVjdCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmFsdWUgPD0gdGhpcy5nZXRWYWx1ZU9mSW5kZXgoMSkpIHtcbiAgICAgICAgdGhpcy5fX2V2ZW50TGlzdFswXVsxXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fX2V2ZW50TGlzdC5zaGlmdCgpO1xuICAgICAgICB0aGlzLmluc2VydChvYmplY3QsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGZpcnN0IGV2ZW50IGZyb20gdGhlIGV2ZW50IGxpc3QuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIEV2ZW50UXVldWUucHJvdG90eXBlLmdldEZpcnN0RXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fX2V2ZW50TGlzdFswXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgb2JqZWN0IG9mIGZpcnN0IGV2ZW50IGZyb20gdGhlIGV2ZW50IGxpc3QuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIEV2ZW50UXVldWUucHJvdG90eXBlLmdldEZpcnN0T2JqZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX19ldmVudExpc3RbMF1bMF07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHZhbHVlIG9mIGZpcnN0IGV2ZW50IGZyb20gdGhlIGV2ZW50IGxpc3QgKGVpdGhlciB0aW1lIG9yIHBvc2l0aW9uKS5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgRXZlbnRRdWV1ZS5wcm90b3R5cGUuZ2V0Rmlyc3RWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9fZXZlbnRMaXN0WzBdWzFdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB2YWx1ZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50IGZyb20gdGhlIGV2ZW50IGxpc3QgKGVpdGhlciB0aW1lIG9yIHBvc2l0aW9uKS5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgRXZlbnRRdWV1ZS5wcm90b3R5cGUuZ2V0VmFsdWVPZkluZGV4ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICBpZiAodGhpcy5fX2V2ZW50TGlzdFtpbmRleF0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZXZlbnRMaXN0W2luZGV4XVsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGbHVzaCB0aGUgZXZlbnQgbGlzdC5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgRXZlbnRRdWV1ZS5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9fZXZlbnRMaXN0ID0gW107XG4gIH1cblxuXG4gIC8qKlxuICAgKiBTb3J0IHRoZSB3aG9sZSBldmVudCBsaXN0LlxuICAgKiBAcHVibGljXG4gICAqL1xuICBFdmVudFF1ZXVlLnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX19pc0JhY2t3YXJkKSB7XG4gICAgICB0aGlzLl9fZXZlbnRMaXN0LnNvcnQodGhpcy5fX3JldmVyc2VDb21wYXJlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fX2V2ZW50TGlzdC5zb3J0KHRoaXMuX19jb21wYXJlKTtcbiAgICB9XG4gIH1cblxuO3JldHVybiBFdmVudFF1ZXVlO30pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRRdWV1ZTsiLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcImV2ZW50LXF1ZXVlXCIsXG4gIFwidmVyc2lvblwiOiBcIjAuMi4wXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJXQVZFIGF1ZGlvIGxpYnJhcnkgbW9kdWxlIGZvciBhbiBldmVudCBxdWV1ZVwiLFxuICBcIm1haW5cIjogXCJpbmRleC5qc1wiLFxuICBcImV4cG9ydHNcIjogXCJjcmVhdGVFdmVudFF1ZXVlXCIsXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJ0ZXN0XCI6IFwiZWNobyBcXFwiRXJyb3I6IG5vIHRlc3Qgc3BlY2lmaWVkXFxcIiAmJiBleGl0IDFcIlxuICB9LFxuICBcImF1dGhvclwiOiBcIkthcmltIEJhcmthdGlcIixcbiAgXCJhdXRob3JzXCI6IFtcbiAgICBcIkthcmltIEJhcmthdGlcIixcbiAgICBcIk5vcmJlcnQgU2NobmVsbFwiLFxuICAgIFwiVmljdG9yIFNhaXpcIlxuICBdLFxuICBcImxpY2Vuc2VcIjogXCJCU0QtMy1DbGF1c2VcIixcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImh0dHA6Ly9naXRodWIuY29tL0lyY2FtLVJuRC9ldmVudC1xdWV1ZS5naXRcIlxuICB9LFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJtb2R1bGUtYm9pbGVycGxhdGVcIjogXCJnaXQ6Ly9naXRodWIuY29tL0lyY2FtLVJuRC9tb2R1bGUtYm9pbGVycGxhdGUuZ2l0I21hc3RlclwiLFxuICAgIFwiZnMtdXRpbHNcIiA6IFwiMC40LjNcIixcbiAgICBcImJyb3dzZXJpZnlcIjogXCJ+NC4xLjJcIixcbiAgICBcIm1vY2hhXCI6IFwifjEuMTcuMVwiLFxuICAgIFwiY2hhaVwiOiBcIn4xLjkuMFwiLFxuICAgIFwiYmxhbmtldFwiOiBcIn4xLjEuNlwiLFxuICAgIFwiZ3VscFwiOiBcIn4zLjguMlwiXG4gIH1cbn0iLCIvKiBHZW5lcmF0ZWQgYnkgZXM2LXRyYW5zcGlsZXIgdiAwLjcuMTQtMiAqL1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFdBVkUgYXVkaW8gbGlicmFyeSBlbGVtZW50OiB0aGUgbWFpbiBhdWRpbyBzY2hlZHVsZXIgb2YgdGhlIGxpYnJhcnksXG4gKiBhcyBhIHNpbmdsZXRvbiBpbiB0aGUgZ2xvYmFsIHZhcmlhYmxlICd3YWtvJy5cbiAqIEBhdXRob3IgS2FyaW0uQmFya2F0aUBpcmNhbS5mciwgTm9yYmVydC5TY2huZWxsQGlyY2FtLmZyLCBWaWN0b3IuU2FpekBpcmNhbS5mclxuICogQHZlcnNpb24gNS4xLjBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIEVuc3VyZSB0aGVyZSBpcyBhIGdsb2JhbGx5IGF2YWlsYWJsZSBcImF1ZGlvQ29udGV4dFwiIGluc3RhbmNlIG9mIHRoZSB3ZWIgYXVkaW8gQXVkaW9Db250ZXh0Llxud2luZG93LmF1ZGlvQ29udGV4dCA9IHdpbmRvdy5hdWRpb0NvbnRleHQgfHwgbmV3IEF1ZGlvQ29udGV4dCgpO1xuXG52YXIgU2NoZWR1bGVyID0gcmVxdWlyZShcIi4uL3NjaGVkdWxlclwiKTtcblxudmFyIE1haW5TY2hlZHVsZXIgPSAoZnVuY3Rpb24oKXt2YXIgRFAkMCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuICBmdW5jdGlvbiBNYWluU2NoZWR1bGVyKCkge1xuXG4gICAgdGhpcy5uYW1lID0gXCJ3YWtvLnNjaGVkdWxlclwiXG4gICAgLy8gSG93IGZyZXF1ZW50bHkgdG8gY2FsbCBzY2hlZHVsaW5nIGZ1bmN0aW9uIChzZWMpLlxuICAgIHRoaXMuc2NoZWR1bGluZ1BlcmlvZCA9ICAwLjAyNTtcbiAgICAvLyBIb3cgZmFyIGFoZWFkIHRvIHNjaGVkdWxlIGV2ZW50cyAoc2VjKSwgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBzY2hlZHVsaW5nUGVyaW9kLlxuICAgIHRoaXMuc2NoZWR1bGVBaGVhZFRpbWUgPSAwLjE7IFxuICAgIHRoaXMuc2NoZWR1bGVyID0gbmV3IFNjaGVkdWxlcigpO1xuXG4gICAgdGhpcy50aW1lcklEID0gbnVsbDtcblxuICAgIHRoaXMuc2NoZWR1bGVyLnNldFBhcmVudCh0aGlzLCB0aGlzLm9uUnVubmluZ1N0YXR1c0NoYW5nZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1EUCQwKE1haW5TY2hlZHVsZXIsIFwicHJvdG90eXBlXCIsIHtcImNvbmZpZ3VyYWJsZVwiOiBmYWxzZSwgXCJlbnVtZXJhYmxlXCI6IGZhbHNlLCBcIndyaXRhYmxlXCI6IGZhbHNlfSk7XG5cbiAgLyoqXG4gICAqIFJlYWN0IHRvIHJ1bm5pbmcgc3RhdHVzIGNoYW5nZSBvZiB0aGUgbWFpbiBzY2hlZHVsZXIgdGhyb3VnaCB0aGlzIGNhbGxiYWNrLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTWFpblNjaGVkdWxlci5wcm90b3R5cGUub25SdW5uaW5nU3RhdHVzQ2hhbmdlID0gZnVuY3Rpb24oYm9vbCkge1xuICAgIGNvbnNvbGUubG9nKFwib25SdW5uaW5nU3RhdHVzQ2hhbmdlIChtYWluU2NoZWR1bGVyKVwiLCBib29sKTtcbiAgICBpZiAoYm9vbCkge1xuICAgICAgdGhpcy5wYXJlbnQuc3RhcnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXJlbnQuc3RvcCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2Fyc2UtZ3JhaW5lZCBzY2hlZHVsaW5nIG9mIGF1ZGlvIGV2ZW50cy5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgTWFpblNjaGVkdWxlci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7IC8vIGZvciB0aGUgc2V0VGltZW91dCBjbG9zdXJlLCBmYXN0ZXIgdGhhbiBhIGJpbmQoKVxuICAgIHZhciBuZXh0RXZlbnRUaW1lID0gSW5maW5pdHk7XG5cbiAgICAvLyBXaGlsZSB0aGVyZSBhcmUgZXZlbnRzIHRoYXQgd2lsbCBuZWVkIHRvIGJlIHBsYXllZCBiZWZvcmUgdGhlIG5leHQgaW50ZXJ2YWwsIFxuICAgIC8vIHNjaGVkdWxlIHRoZW0gYW5kIGFkdmFuY2UgdGhlIHRpbWUgcG9pbnRlci5cbiAgICBuZXh0RXZlbnRUaW1lID0gdGhpcy5zY2hlZHVsZXIuZ2V0TmV4dFRpbWUoKTtcbiAgICB3aGlsZSAobmV4dEV2ZW50VGltZSA8PSBhdWRpb0NvbnRleHQuY3VycmVudFRpbWUgKyB0aGlzLnNjaGVkdWxlQWhlYWRUaW1lKSB7XG4gICAgICAvLyBuZXh0RXZlbnRUaW1lID0gdGhpcy5zY2hlZHVsZXIubWFrZUV2ZW50QW5kUmV0dXJuTmV4dFRpbWUoKTtcbiAgICAgIHRoaXMuc2NoZWR1bGVyLm1ha2VOZXh0RXZlbnQoKTtcbiAgICAgIG5leHRFdmVudFRpbWUgPSB0aGlzLnNjaGVkdWxlci5nZXROZXh0VGltZSgpO1xuICAgIH1cbiAgICAvLyBTdG9yZSB0aGUgc2V0VGltZW91dCBJRCB0byBhbGxvdyByZW1vdmluZy5cbiAgICB0aGlzLnRpbWVySUQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgdGhhdC5zdGFydCgpO1xuICAgIH0sIHRoYXQuc2NoZWR1bGluZ1BlcmlvZCAqIDEwMDApO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgdGhlIHNjaGVkdWxpbmcgbG9vcC5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgTWFpblNjaGVkdWxlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVySUQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcndhcmQgdGhlIGFkZCgpIG1ldGhvZCB0byB0aGUgaW50ZXJuYWwgc2NoZWR1bGVyLlxuICAgKiBAcHVibGljXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIE1haW5TY2hlZHVsZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHRoaXMuc2NoZWR1bGVyLmFkZChvYmplY3QpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcndhcmQgdGhlIHJlbW92ZSgpIG1ldGhvZCB0byB0aGUgaW50ZXJuYWwgc2NoZWR1bGVyLlxuICAgKiBAcHVibGljXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIE1haW5TY2hlZHVsZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHRoaXMuc2NoZWR1bGVyLnJlbW92ZShvYmplY3QpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBzY2hlZHVsaW5nIHBlcmlvZC5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgTWFpblNjaGVkdWxlci5wcm90b3R5cGUuZ2V0U2NoZWR1bGluZ1BlcmlvZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNjaGVkdWxpbmdQZXJpb2Q7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgdGltZSBmcm9tIHRoZSBXZWIgQXVkaW8gY29udGV4dC5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgTWFpblNjaGVkdWxlci5wcm90b3R5cGUuZ2V0Q3VycmVudFRpbWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lO1xuICB9XG5cbjtyZXR1cm4gTWFpblNjaGVkdWxlcjt9KSgpO1xuXG4vLyBFbnN1cmUgdGhlcmUgaXMgYSBnbG9iYWxseSBhdmFpbGFibGUgXCJ3YWtvXCIgaW5zdGFuY2Ugb2YgdGhlIFdBVkUncyBnbG9iYWwgbmFtZS1zcGFjZS5cbndpbmRvdy53YWtvID0gd2luZG93Lndha28gfHwge307XG5cbi8vIFByb3ZpZGUgd2FrbyB3aXRoIGEgTWFpblNjaGVkdWxlciBzaW5nbGV0b24sIG9ubHkgaWYgbm90IGFscmVhZHkgdGhlcmUuXG53YWtvLnNjaGVkdWxlciA9IHdha28uc2NoZWR1bGVyIHx8IG5ldyBNYWluU2NoZWR1bGVyKCk7IiwiLyogR2VuZXJhdGVkIGJ5IGVzNi10cmFuc3BpbGVyIHYgMC43LjE0LTIgKi9cbi8qKlxuICogQGZpbGVvdmVydmlldyBXQVZFIGF1ZGlvIGxpYnJhcnkgZWxlbWVudDogYSB3ZWIgYXVkaW8gc2NoZWR1bGVyLCB3aXRob3V0IHRpbWUgbG9vcC5cbiAqIEBhdXRob3IgS2FyaW0uQmFya2F0aUBpcmNhbS5mciwgTm9yYmVydC5TY2huZWxsQGlyY2FtLmZyLCBWaWN0b3IuU2FpekBpcmNhbS5mclxuICogQHZlcnNpb24gNC4xLjBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudFF1ZXVlID0gcmVxdWlyZShcIi4uL2V2ZW50LXF1ZXVlXCIpO1xuXG4vLyBNYWtlIGEgZ2xvYmFsIGluc3RhbmNlIG9mIHRoZSB3YWtvLnNjaGVkdWxlciBhdmFpbGFibGVcbnJlcXVpcmUoXCIuLi9tYWluLXNjaGVkdWxlclwiKTtcblxudmFyIFNjaGVkdWxlciA9IChmdW5jdGlvbigpe3ZhciBEUCQwID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG4gIGZ1bmN0aW9uIFNjaGVkdWxlcihvcHROYW1lKSB7XG5cbiAgICBpZiAoIXRoaXMgfHwgdGhpcyA9PT0gd2luZG93KVxuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiWW91IHNlZW0gdG8gaGF2ZSBmb3Jnb3R0ZW4gdGhlIG5ldyBvcGVyYXRvcjsgU2hhbWUgb24geW91IVwiKTtcblxuICAgIHRoaXMubmFtZSA9IG9wdE5hbWUgfHwgXCJTY2hlZHVsZXJcIjtcbiAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlOyAgICBcbiAgICB0aGlzLmV2ZW50UXVldWUgPSBudWxsO1xuICAgIHRoaXMubmV4dEV2ZW50VGltZSA9IEluZmluaXR5XG4gICAgdGhpcy5zY2hlZHVsYWJsZXNMaXN0ID0gW11cbiAgICB0aGlzLnBhcmVudCA9IG51bGxcbiAgICAvLyByZXF1aXJlZCBtZXRob2QsIGZyb20gdGhlIHBhcmVudFxuICAgIHRoaXMucnVubmluZ1N0YXR1c0NoYW5nZUNhbGxiYWNrID0gbnVsbDtcbiAgICB0aGlzLmV2ZW50UXVldWUgPSBuZXcgRXZlbnRRdWV1ZSgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1EUCQwKFNjaGVkdWxlciwgXCJwcm90b3R5cGVcIiwge1wiY29uZmlndXJhYmxlXCI6IGZhbHNlLCBcImVudW1lcmFibGVcIjogZmFsc2UsIFwid3JpdGFibGVcIjogZmFsc2V9KTtcblxuICAvKipcbiAgICogU2NoZWR1bGUgYSBzY2hlZHVsYWJsZSBvYmplY3QgYW5kIGFkZCBpdCB0byB0aGUgc2NoZWR1bGluZyBsaXN0LlxuICAgKiBAcHVibGljXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIFNjaGVkdWxlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgb2JqZWN0LnNjaGVkdWxlciA9IHRoaXM7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMuc2NoZWR1bGFibGVzTGlzdC5wdXNoKG9iamVjdCk7XG4gICAgdmFyIGluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICB2YXIgbmFtZSA9IG9iamVjdC5uYW1lID8gb2JqZWN0Lm5hbWUgOiBvYmplY3Quc2NoZWR1bGluZ0lEO1xuICAgIGNvbnNvbGUubG9nKFwiYWRkKCk6XCIsIHRoaXMubmFtZSwgXCJzY2hlZHVsaW5nIGVsZW1lbnQgI1wiICsgaW5kZXggKyAnIFxcXCInICsgbmFtZSArICdcXFwiJyk7XG4gICAgaWYgKCF0aGlzLmlzUnVubmluZykge1xuICAgICAgLy8gdGhpcy5yZXNldEFsbCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnNjaGVkdWxlIGEgc2NoZWR1bGFibGUgb2JqZWN0IGFuZCByZW1vdmUgaXQgZnJvbSB0aGUgc2NoZWR1bGluZyBsaXN0LlxuICAgKiBAcHVibGljXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIFNjaGVkdWxlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgLy8gU2VhcmNoIGZvciB0aGUgb2JqZWN0IGluIHRoZSBzY2hlZHVsaW5nIGxpc3QuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5zY2hlZHVsYWJsZXNMaXN0LmluZGV4T2Yob2JqZWN0KTtcblxuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInJlbW92ZSgpOiBvYmplY3Qgbm90IGZvdW5kLFwiICsgb2JqZWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zY2hlZHVsYWJsZXNMaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICBjb25zb2xlLmxvZyhcIlVuc2NoZWR1bGluZyBlbGVtZW50ICNcIiArIGluZGV4LCBvYmplY3QubmFtZSA/ICdcXFwiJyArIG9iamVjdC5uYW1lICsgJ1xcXCInIDogXCJcIiwgb2JqZWN0LnNjaGVkdWxpbmdJRCk7XG4gICAgICAvLyBXaGVuIHRoZSBzY2hlZHVsaW5nIGxpc3QgaXMgZW1wdHksIHN0b3Agc2NoZWR1bGluZy5cbiAgICAgIGlmICh0aGlzLnNjaGVkdWxhYmxlc0xpc3QubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHNjaGVkdWxpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBTY2hlZHVsZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmlzUnVubmluZykge1xuICAgICAgdGhpcy5pc1J1bm5pbmcgPSB0cnVlO1xuICAgICAgY29uc29sZS5sb2coXCJTY2hlZHVsaW5nIG9uXCIsIFwiKFwiICsgdGhpcy5uYW1lICsgXCIpXCIpO1xuICAgICAgdGhpcy5ydW5uaW5nU3RhdHVzQ2hhbmdlQ2FsbGJhY2sodGhpcy5pc1J1bm5pbmcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIHNjaGVkdWxpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBTY2hlZHVsZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgIGNvbnNvbGUubG9nKFwiU2NoZWR1bGluZyBvZmYgKFwiICsgdGhpcy5uYW1lICsgXCIpXCIpO1xuICAgIHRoaXMucnVubmluZ1N0YXR1c0NoYW5nZUNhbGxiYWNrKHRoaXMuaXNSdW5uaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBhbGwgc2NoZWR1bGFibGVzIG9iamVjdHMgb2YgdGhpcyBzY2hlZHVsZXIuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIFNjaGVkdWxlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmV2ZW50UXVldWUuZmx1c2goKTtcbiAgICB0aGlzLmluc2VydEFsbCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1c2ggYWxsIGV2ZW50cyBpbnRvIHRoZSBldmVudCBxdWV1ZSBhbmQgc29ydCBpdCBhZnRlcndhcmQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBTY2hlZHVsZXIucHJvdG90eXBlLmluc2VydEFsbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aW1lID0gbnVsbDtcbiAgICB2YXIgZWxlbWVudCA9IG51bGw7XG4gICAgLy8gY29uc29sZS5sb2coXCJzY2hlZHVsYWJsZXNMaXN0OiBcIiwgdGhpcy5zY2hlZHVsYWJsZXNMaXN0KTtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5zY2hlZHVsYWJsZXNMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBlbGVtZW50ID0gdGhpcy5zY2hlZHVsYWJsZXNMaXN0W2ldO1xuICAgICAgdGltZSA9IGVsZW1lbnQucmVzZXRBbmRSZXR1cm5OZXh0VGltZSh0aGlzLmdldEN1cnJlbnRUaW1lKCkpO1xuICAgICAgdGhpcy5ldmVudFF1ZXVlLnB1c2hFdmVudChlbGVtZW50LCB0aW1lKTtcbiAgICB9XG4gICAgdGhpcy5ldmVudFF1ZXVlLnNvcnQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnQgYW4gZXZlbnQgaW50byB0aGUgZXZlbnQgcXVldWUuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIFNjaGVkdWxlci5wcm90b3R5cGUuaW5zZXJ0RXZlbnQgPSBmdW5jdGlvbihvYmplY3QsIHRpbWUpIHtcbiAgICBpZiAodGltZSAhPT0gSW5maW5pdHkpIHtcbiAgICAgIHRoaXMuZXZlbnRRdWV1ZS5JbnNlcnQob2JqZWN0LCB0aW1lKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgdGltZSBmcm9tIHdha28uc2NoZWR1bGVyLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBTY2hlZHVsZXIucHJvdG90eXBlLmdldEN1cnJlbnRUaW1lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHdha28uc2NoZWR1bGVyLmdldEN1cnJlbnRUaW1lKCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIG5leHQgc2NoZWR1bGluZyB0aW1lIG9mIGEgc2NoZWR1bGVkIG9iamVjdC5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCByZWZlcmVuY2VcbiAgICogQHBhcmFtIHtGbG9hdH0gbmV3IHNjaGVkdWxpbmcgdGltZSBvZiBpdHMgbmV4dCBldmVudDsgXCJJbmZpbml0eVwiIG1lYW5zIFwicmVtb3ZlIGZyb20gc2NoZWR1bGluZ1wiXG4gICAqL1xuICBTY2hlZHVsZXIucHJvdG90eXBlLnVwZGF0ZU5leHRUaW1lID0gZnVuY3Rpb24ob2JqZWN0LCB0aW1lKSB7XG4gICAgaWYgKHRpbWUgPT09IEluZmluaXR5KSB7XG4gICAgICB0aGlzLmV2ZW50UXVldWUucmVtb3ZlKG9iamVjdCk7XG4gICAgICAvLyBJZiB0aGUgcXVldWUgaXMgZW1wdHksIHN0b3Agc2NoZWR1bGluZy5cbiAgICAgIGlmICh0aGlzLmV2ZW50UXVldWUubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmV2ZW50UXVldWUuaW5kZXhPZihvYmplY3QpIDwgMCkge1xuICAgICAgICB0aGlzLmV2ZW50UXVldWUuaW5zZXJ0KG9iamVjdCwgdGltZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmV2ZW50UXVldWUubW92ZShvYmplY3QsIHRpbWUpO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgcGFyZW50IGFuZCBzdGF0dXMgY2hhbmdlIGNhbGxiYWNrLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50IFRoZSBwYXJlbnQgb2YgYSBzY2hlZHVsZXIgaGFzIHRvIGJlIHNldC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhpcyByZXF1aXJlZCBjYWxsYmFjayB0cmlnZ2VycyB0aGUgcGFyZW50LFxuICAgKiB3aXRoIGEgYm9vbGVhbiBvbiBydW5uaW5nIHN0YXR1cyBjaGFuZ2UuXG4gICAqL1xuICBTY2hlZHVsZXIucHJvdG90eXBlLnNldFBhcmVudCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICB0aGlzLnBhcmVudCA9IG9iamVjdDtcbiAgICB0aGlzLnJ1bm5pbmdTdGF0dXNDaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG5cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLy8gVHJhbnNwb3J0aW5nIG1ldGhvZHMgLy8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgLyoqXG4gICAqIENhbGwgdGhlIGV2ZW50IG1ha2luZyBtZXRob2Qgb2YgdGhlIGZpcnN0IHNjaGVkdWxhYmxlIG9iamVjdCxcbiAgICogYW5kIHRoZW4gdXBkYXRlIHRoZSBmaXJzdCBldmVudCBvZiB0aGUgcXVldWUuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIFNjaGVkdWxlci5wcm90b3R5cGUubWFrZU5leHRFdmVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlbmdpbmUgPSB0aGlzLmV2ZW50UXVldWUuZ2V0Rmlyc3RPYmplY3QoKTtcbiAgICB0aGlzLm5leHRFdmVudFRpbWUgPSBlbmdpbmUubWFrZUV2ZW50QW5kUmV0dXJuTmV4dFRpbWUoKTtcbiAgICB0aGlzLmV2ZW50UXVldWUubW92ZUZpcnN0RXZlbnQoZW5naW5lLCB0aGlzLm5leHRFdmVudFRpbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBuZXh0IGV2ZW50IHRpbWUgYnkgcXVlcnlpbmcgaXQgaW4gdGhlIGV2ZW50IHF1ZXVlLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBTY2hlZHVsZXIucHJvdG90eXBlLmdldE5leHRUaW1lID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuc2NoZWR1bGFibGVzTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLm5leHRFdmVudFRpbWUgPSB0aGlzLmV2ZW50UXVldWUuZ2V0Rmlyc3RWYWx1ZSgpO1xuICAgICAgcmV0dXJuIHRoaXMubmV4dEV2ZW50VGltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgfVxuXG47cmV0dXJuIFNjaGVkdWxlcjt9KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVkdWxlcjsiXX0=
