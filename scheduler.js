(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/* Generated by es6-transpiler v 0.7.14-2 *//**
 * @fileoverview WAVE audio library element: an event queue manager.
 * @author Karim.Barkati@ircam.fr, Norbert.Schnell@ircam.fr, Victor.Saiz@ircam.fr
 * @version 0.3.2
 * @description An event is made of an object (such as an engine) and a value (such as a time or a position).
 */

'use strict';

var EventQueue = (function(){var DP$0 = Object.defineProperty;
  
  function EventQueue() {
    if (!(this instanceof EventQueue)) throw new Error('You seem to have forgotten the new operatorâ€¦ shame on you!');

    this.eventList = [];
    this.name = require('./package.json').name;
    
    this.__isBackward = false;
  }Object.defineProperties(EventQueue.prototype, {length: {"get": length$get$0, "configurable": true, "enumerable": true}});DP$0(EventQueue, "prototype", {"configurable": false, "enumerable": false, "writable": false});

  /**
   * Compare two events based on their value only.
   * @private
   * @param {Event} a
   * @param {Event} b
   */
  EventQueue.prototype.__compare = function(a, b) {
    return a[1] - b[1];
  }

  /**
   * Compare two events based on their value only, in reverse order.
   * @private
   * @param {Event} a
   * @param {Event} b
   */
  EventQueue.prototype.__reverseCompare = function(a, b) {
    return b[1] - a[1];
  }

  /**
   * Get the index of an object in the event list.
   * @private
   */
  EventQueue.prototype.__indexOf = function(object) {
    var i = null;
    for (i = 0; i < this.__eventList.length; i++) {
      if (object === this.__eventList[i][0]) {
        return i;
      }
    }
    return -1;
  }

  // this.length helper
  function length$get$0() {
    return this.__eventList.length;
  }

  /**
   * Insert an event (an ordered pair [object, value]) into eventList.
   * @public
   * @param {Object} object reference
   * @param {Float} value for scheduling or sequencing, ie either time or position value
   */
  EventQueue.prototype.insert = function(object, value) {
    this.pushEvent(object, value);
    this.sort();
  }

  /**
   * Push an event (an ordered pair [object, value]) into eventList without sorting.
   * @public
   * @param {Object} object reference
   * @param {Float} value for scheduling or sequencing, ie either time or position value
   */
  EventQueue.prototype.pushEvent = function(object, value) {
    this.__eventList.push([object, value]);
  }

  /**
   * Remove an event from the event list.
   * @public
   * @chainable
   * @param {Object} object of the event to remove (1 to 1 hypothesis)
   */
  EventQueue.prototype.remove = function(object) {
    if (object) {
      // Search for the index of the object in the list (not the full event pair).
      var index = this.__indexOf(object);
      if (index < 0) {
        throw new Error("remove(): no object");
      } else {
        this.__eventList.splice(index, 1);
      }
      return this; // for chainability
    } else {
      throw new ReferenceError("remove(): no object");
    }
  }

  /**
   * Move an event (an ordered pair [object, value]) into the event list.
   * @public
   * @param {Object} object reference
   * @param {Float} value for scheduling or sequencing, i.e. either time or position value
   * @todo Optimize algorithm: at least, test if moving is necessary?
   */
  EventQueue.prototype.move = function(object, value) {
    this.remove(object);
    this.insert(object, value);
  }

  /**
   * Move the first event of the event list only if needed.
   * @public
   * @param {Object} object reference
   * @param {Float} value for scheduling or sequencing, ie either time or position value
   */
  EventQueue.prototype.moveFirstEvent = function(object, value) {
    if (this.__isBackward) {
      if (value > this.getValueOfIndex(1)) {
        this.__eventList[0][1] = value;
      } else {
        this.__eventList.shift();
        this.insert(object, value);
      }
    } else {
      if (value <= this.getValueOfIndex(1)) {
        this.__eventList[0][1] = value;
      } else {
        this.__eventList.shift();
        this.insert(object, value);
      }
    }
  }

  /**
   * Get first event from the event list.
   * @public
   */
  EventQueue.prototype.getFirstEvent = function() {
    return this.__eventList[0];
  }

  /**
   * Get object of first event from the event list.
   * @public
   */
  EventQueue.prototype.getFirstObject = function() {
    return this.__eventList[0][0];
  }

  /**
   * Get value of first event from the event list (either time or position).
   * @public
   */
  EventQueue.prototype.getFirstValue = function() {
    return this.__eventList[0][1];
  }

  /**
   * Get value of the specified event from the event list (either time or position).
   * @public
   */
  EventQueue.prototype.getValueOfIndex = function(index) {
    if (this.__eventList[index]) {
      return this.__eventList[index][1];
    } else {
      return Infinity;
    }
  }

  /**
   * Flush the event list.
   * @public
   */
  EventQueue.prototype.flush = function() {
    this.__eventList = [];
  }


  /**
   * Sort the whole event list.
   * @public
   */
  EventQueue.prototype.sort = function() {
    if (this.__isBackward) {
      this.__eventList.sort(this.__reverseCompare);
    } else {
      this.__eventList.sort(this.__compare);
    }
  }

;return EventQueue;})();

module.exports = EventQueue;
},{"./package.json":2}],2:[function(require,module,exports){
module.exports={
  "name": "event-queue",
  "version": "0.2.0",
  "description": "WAVE audio library module for an event queue",
  "main": "index.js",
  "exports": "createEventQueue",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "Karim Barkati",
  "authors": [
    "Karim Barkati",
    "Norbert Schnell",
    "Victor Saiz"
  ],
  "license": "BSD-3-Clause",
  "repository": {
    "type": "git",
    "url": "http://github.com/Ircam-RnD/event-queue.git"
  },
  "devDependencies": {
    "module-boilerplate": "git://github.com/Ircam-RnD/module-boilerplate.git#master",
    "fs-utils" : "0.4.3",
    "browserify": "~4.1.2",
    "mocha": "~1.17.1",
    "chai": "~1.9.0",
    "blanket": "~1.1.6",
    "gulp": "~3.8.2"
  }
}
},{}],3:[function(require,module,exports){
/* Generated by es6-transpiler v 0.7.14-2 */
/**
 * @fileoverview WAVE audio library element: the main audio scheduler of the library,
 * as a singleton in the global variable 'wako'.
 * @author Karim.Barkati@ircam.fr, Norbert.Schnell@ircam.fr, Victor.Saiz@ircam.fr
 * @version 5.1.0
 */

'use strict';

// Ensure there is a globally available "audioContext" instance of the web audio AudioContext.
window.audioContext = window.audioContext || new AudioContext();

var Scheduler = require("../scheduler");

var MainScheduler = (function(){var DP$0 = Object.defineProperty;

  function MainScheduler() {

    this.name = "wako.scheduler"
    // How frequently to call scheduling function (sec).
    this.schedulingPeriod =  0.025;
    // How far ahead to schedule events (sec), should be greater than schedulingPeriod.
    this.scheduleAheadTime = 0.1; 
    this.scheduler = new Scheduler();

    this.timerID = null;

    this.scheduler.setParent(this, this.onRunningStatusChange);
    return this;
  }DP$0(MainScheduler, "prototype", {"configurable": false, "enumerable": false, "writable": false});

  /**
   * React to running status change of the main scheduler through this callback.
   * @private
   */
  MainScheduler.prototype.onRunningStatusChange = function(bool) {
    console.log("onRunningStatusChange (mainScheduler)", bool);
    if (bool) {
      this.parent.start();
    } else {
      this.parent.stop();
    }
  }

  /**
   * Coarse-grained scheduling of audio events.
   * @public
   */
  MainScheduler.prototype.start = function() {
    var that = this; // for the setTimeout closure, faster than a bind()
    var nextEventTime = Infinity;

    // While there are events that will need to be played before the next interval, 
    // schedule them and advance the time pointer.
    nextEventTime = this.scheduler.getNextTime();
    while (nextEventTime <= audioContext.currentTime + this.scheduleAheadTime) {
      // nextEventTime = this.scheduler.makeEventAndReturnNextTime();
      this.scheduler.makeNextEvent();
      nextEventTime = this.scheduler.getNextTime();
    }
    // Store the setTimeout ID to allow removing.
    this.timerID = setTimeout(function() {
      that.start();
    }, that.schedulingPeriod * 1000);
  }

  /**
   * Stop the scheduling loop.
   * @public
   */
  MainScheduler.prototype.stop = function() {
    clearTimeout(this.timerID);
  }

  /**
   * Forward the add() method to the internal scheduler.
   * @public
   * @chainable
   */
  MainScheduler.prototype.add = function(object) {
    this.scheduler.add(object);
    return this;
  }

  /**
   * Forward the remove() method to the internal scheduler.
   * @public
   * @chainable
   */
  MainScheduler.prototype.remove = function(object) {
    this.scheduler.remove(object);
    return this;
  }

  /**
   * Get scheduling period.
   * @public
   */
  MainScheduler.prototype.getSchedulingPeriod = function() {
    return this.schedulingPeriod;
  }

  /**
   * Get current time from the Web Audio context.
   * @public
   */
  MainScheduler.prototype.getCurrentTime = function() {
    return audioContext.currentTime;
  }

;return MainScheduler;})();

// Ensure there is a globally available "wako" instance of the WAVE's global name-space.
window.wako = window.wako || {};

// Provide wako with a MainScheduler singleton, only if not already there.
wako.scheduler = wako.scheduler || new MainScheduler();
},{"../scheduler":4}],4:[function(require,module,exports){
/* Generated by es6-transpiler v 0.7.14-2 */
/**
 * @fileoverview WAVE audio library element: a web audio scheduler, without time loop.
 * @author Karim.Barkati@ircam.fr, Norbert.Schnell@ircam.fr, Victor.Saiz@ircam.fr
 * @version 4.1.0
 */

'use strict';

var EventQueue = require("../event-queue");

// Make a global instance of the wako.scheduler available
require("../main-scheduler");

var Scheduler = (function(){var DP$0 = Object.defineProperty;

  function Scheduler(optName) {

    if (!this || this === window)
      throw new SyntaxError("You seem to have forgotten the new operator; Shame on you!");

    this.name = optName || "Scheduler";
    this.isRunning = false;    
    this.eventQueue = null;
    this.nextEventTime = Infinity
    this.schedulablesList = []
    this.parent = null
    // required method, from the parent
    this.runningStatusChangeCallback = null;
    this.eventQueue = new EventQueue();

    return this;
  }DP$0(Scheduler, "prototype", {"configurable": false, "enumerable": false, "writable": false});

  /**
   * Schedule a schedulable object and add it to the scheduling list.
   * @public
   * @chainable
   */
  Scheduler.prototype.add = function(object) {
    
    object.scheduler = this;
    var length = this.schedulablesList.push(object);
    var index = length - 1;
    var name = object.name ? object.name : object.schedulingID;
    console.log("add():", this.name, "scheduling element #" + index + ' \"' + name + '\"');
    if (!this.isRunning) {
      // this.resetAll();
    }
    return this;
  }

  /**
   * Unschedule a schedulable object and remove it from the scheduling list.
   * @public
   * @chainable
   */
  Scheduler.prototype.remove = function(object) {
    // Search for the object in the scheduling list.
    var index = this.schedulablesList.indexOf(object);

    if (index < 0) {
      throw new Error("remove(): object not found," + object);
    } else {
      this.schedulablesList.splice(index, 1);
      console.log("Unscheduling element #" + index, object.name ? '\"' + object.name + '\"' : "", object.schedulingID);
      // When the scheduling list is empty, stop scheduling.
      if (this.schedulablesList.length <= 0) {
        this.stop();
      }
    }
    return this;
  }

  /**
   * Start scheduling.
   * @private
   */
  Scheduler.prototype.start = function() {
    if (!this.isRunning) {
      this.isRunning = true;
      console.log("Scheduling on", "(" + this.name + ")");
      this.runningStatusChangeCallback(this.isRunning);
    }
  }

  /**
   * Stop scheduling.
   * @private
   */
  Scheduler.prototype.stop = function() {
    this.isRunning = false;
    console.log("Scheduling off (" + this.name + ")");
    this.runningStatusChangeCallback(this.isRunning);
  }

  /**
   * Reset all schedulables objects of this scheduler.
   * @public
   */
  Scheduler.prototype.reset = function() {
    this.eventQueue.flush();
    this.insertAll();
  }

  /**
   * Push all events into the event queue and sort it afterward.
   * @private
   */
  Scheduler.prototype.insertAll = function() {
    var time = null;
    var element = null;
    // console.log("schedulablesList: ", this.schedulablesList);
    for (var i = this.schedulablesList.length - 1; i >= 0; i--) {
      element = this.schedulablesList[i];
      time = element.resetAndReturnNextTime(this.getCurrentTime());
      this.eventQueue.pushEvent(element, time);
    }
    this.eventQueue.sort();
  }

  /**
   * Insert an event into the event queue.
   * @public
   */
  Scheduler.prototype.insertEvent = function(object, time) {
    if (time !== Infinity) {
      this.eventQueue.Insert(object, time);
    }
  }

  /**
   * Get current time from wako.scheduler.
   * @public
   */
  Scheduler.prototype.getCurrentTime = function() {
    return wako.scheduler.getCurrentTime();
  }

  /**
   * Update next scheduling time of a scheduled object.
   * @private
   * @param {Object} object reference
   * @param {Float} new scheduling time of its next event; "Infinity" means "remove from scheduling"
   */
  Scheduler.prototype.updateNextTime = function(object, time) {
    if (time === Infinity) {
      this.eventQueue.remove(object);
      // If the queue is empty, stop scheduling.
      if (this.eventQueue.length <= 0) {
        this.stop();
      }
    } else {
      if (this.eventQueue.indexOf(object) < 0) {
        this.eventQueue.insert(object, time);
      } else {
        this.eventQueue.move(object, time);
      }
      this.start();
    }
  }

  /**
   * Set parent and status change callback.
   * @private
   * @param {Object} parent The parent of a scheduler has to be set.
   * @param {Function} callback This required callback triggers the parent,
   * with a boolean on running status change.
   */
  Scheduler.prototype.setParent = function(object, callback) {
    this.parent = object;
    this.runningStatusChangeCallback = callback;
  }


  /////////////////////////////
  /// Transporting methods ///
  /////////////////////////////

  /**
   * Call the event making method of the first schedulable object,
   * and then update the first event of the queue.
   * @public
   */
  Scheduler.prototype.makeNextEvent = function() {
    var engine = this.eventQueue.getFirstObject();
    this.nextEventTime = engine.makeEventAndReturnNextTime();
    this.eventQueue.moveFirstEvent(engine, this.nextEventTime);
  }

  /**
   * Get next event time by querying it in the event queue.
   * @public
   */
  Scheduler.prototype.getNextTime = function() {
    if (this.schedulablesList.length > 0) {
      this.nextEventTime = this.eventQueue.getFirstValue();
      return this.nextEventTime;
    } else {
      return Infinity;
    }
  }

;return Scheduler;})();

module.exports = Scheduler;
},{"../event-queue":1,"../main-scheduler":3}]},{},[4])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Wb2x1bWVzL0hvbWUvRG9jdW1lbnRzL1dBVkUvZ3VscEJyb3dFcnN5Ni9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwiL1ZvbHVtZXMvSG9tZS9Eb2N1bWVudHMvd2F2ZS9yZXBvL2xpYi9naXRodWIvYXVkaW8vZXZlbnQtcXVldWUvaW5kZXguanMiLCIvVm9sdW1lcy9Ib21lL0RvY3VtZW50cy93YXZlL3JlcG8vbGliL2dpdGh1Yi9hdWRpby9ldmVudC1xdWV1ZS9wYWNrYWdlLmpzb24iLCIvVm9sdW1lcy9Ib21lL0RvY3VtZW50cy93YXZlL3JlcG8vbGliL2dpdGh1Yi9hdWRpby9tYWluLXNjaGVkdWxlci9pbmRleC5qcyIsIi9Wb2x1bWVzL0hvbWUvRG9jdW1lbnRzL3dhdmUvcmVwby9saWIvZ2l0aHViL2F1ZGlvL3NjaGVkdWxlci9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLyogR2VuZXJhdGVkIGJ5IGVzNi10cmFuc3BpbGVyIHYgMC43LjE0LTIgKi8vKipcbiAqIEBmaWxlb3ZlcnZpZXcgV0FWRSBhdWRpbyBsaWJyYXJ5IGVsZW1lbnQ6IGFuIGV2ZW50IHF1ZXVlIG1hbmFnZXIuXG4gKiBAYXV0aG9yIEthcmltLkJhcmthdGlAaXJjYW0uZnIsIE5vcmJlcnQuU2NobmVsbEBpcmNhbS5mciwgVmljdG9yLlNhaXpAaXJjYW0uZnJcbiAqIEB2ZXJzaW9uIDAuMy4yXG4gKiBAZGVzY3JpcHRpb24gQW4gZXZlbnQgaXMgbWFkZSBvZiBhbiBvYmplY3QgKHN1Y2ggYXMgYW4gZW5naW5lKSBhbmQgYSB2YWx1ZSAoc3VjaCBhcyBhIHRpbWUgb3IgYSBwb3NpdGlvbikuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRRdWV1ZSA9IChmdW5jdGlvbigpe3ZhciBEUCQwID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuICBcbiAgZnVuY3Rpb24gRXZlbnRRdWV1ZSgpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRXZlbnRRdWV1ZSkpIHRocm93IG5ldyBFcnJvcignWW91IHNlZW0gdG8gaGF2ZSBmb3Jnb3R0ZW4gdGhlIG5ldyBvcGVyYXRvcuKApiBzaGFtZSBvbiB5b3UhJyk7XG5cbiAgICB0aGlzLmV2ZW50TGlzdCA9IFtdO1xuICAgIHRoaXMubmFtZSA9IHJlcXVpcmUoJy4vcGFja2FnZS5qc29uJykubmFtZTtcbiAgICBcbiAgICB0aGlzLl9faXNCYWNrd2FyZCA9IGZhbHNlO1xuICB9T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRXZlbnRRdWV1ZS5wcm90b3R5cGUsIHtsZW5ndGg6IHtcImdldFwiOiBsZW5ndGgkZ2V0JDAsIFwiY29uZmlndXJhYmxlXCI6IHRydWUsIFwiZW51bWVyYWJsZVwiOiB0cnVlfX0pO0RQJDAoRXZlbnRRdWV1ZSwgXCJwcm90b3R5cGVcIiwge1wiY29uZmlndXJhYmxlXCI6IGZhbHNlLCBcImVudW1lcmFibGVcIjogZmFsc2UsIFwid3JpdGFibGVcIjogZmFsc2V9KTtcblxuICAvKipcbiAgICogQ29tcGFyZSB0d28gZXZlbnRzIGJhc2VkIG9uIHRoZWlyIHZhbHVlIG9ubHkuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGFcbiAgICogQHBhcmFtIHtFdmVudH0gYlxuICAgKi9cbiAgRXZlbnRRdWV1ZS5wcm90b3R5cGUuX19jb21wYXJlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBhWzFdIC0gYlsxXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJlIHR3byBldmVudHMgYmFzZWQgb24gdGhlaXIgdmFsdWUgb25seSwgaW4gcmV2ZXJzZSBvcmRlci5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtFdmVudH0gYVxuICAgKiBAcGFyYW0ge0V2ZW50fSBiXG4gICAqL1xuICBFdmVudFF1ZXVlLnByb3RvdHlwZS5fX3JldmVyc2VDb21wYXJlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBiWzFdIC0gYVsxXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGluZGV4IG9mIGFuIG9iamVjdCBpbiB0aGUgZXZlbnQgbGlzdC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIEV2ZW50UXVldWUucHJvdG90eXBlLl9faW5kZXhPZiA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBpID0gbnVsbDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fX2V2ZW50TGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG9iamVjdCA9PT0gdGhpcy5fX2V2ZW50TGlzdFtpXVswXSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLy8gdGhpcy5sZW5ndGggaGVscGVyXG4gIGZ1bmN0aW9uIGxlbmd0aCRnZXQkMCgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2V2ZW50TGlzdC5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0IGFuIGV2ZW50IChhbiBvcmRlcmVkIHBhaXIgW29iamVjdCwgdmFsdWVdKSBpbnRvIGV2ZW50TGlzdC5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHJlZmVyZW5jZVxuICAgKiBAcGFyYW0ge0Zsb2F0fSB2YWx1ZSBmb3Igc2NoZWR1bGluZyBvciBzZXF1ZW5jaW5nLCBpZSBlaXRoZXIgdGltZSBvciBwb3NpdGlvbiB2YWx1ZVxuICAgKi9cbiAgRXZlbnRRdWV1ZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24ob2JqZWN0LCB2YWx1ZSkge1xuICAgIHRoaXMucHVzaEV2ZW50KG9iamVjdCwgdmFsdWUpO1xuICAgIHRoaXMuc29ydCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1c2ggYW4gZXZlbnQgKGFuIG9yZGVyZWQgcGFpciBbb2JqZWN0LCB2YWx1ZV0pIGludG8gZXZlbnRMaXN0IHdpdGhvdXQgc29ydGluZy5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHJlZmVyZW5jZVxuICAgKiBAcGFyYW0ge0Zsb2F0fSB2YWx1ZSBmb3Igc2NoZWR1bGluZyBvciBzZXF1ZW5jaW5nLCBpZSBlaXRoZXIgdGltZSBvciBwb3NpdGlvbiB2YWx1ZVxuICAgKi9cbiAgRXZlbnRRdWV1ZS5wcm90b3R5cGUucHVzaEV2ZW50ID0gZnVuY3Rpb24ob2JqZWN0LCB2YWx1ZSkge1xuICAgIHRoaXMuX19ldmVudExpc3QucHVzaChbb2JqZWN0LCB2YWx1ZV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBldmVudCBmcm9tIHRoZSBldmVudCBsaXN0LlxuICAgKiBAcHVibGljXG4gICAqIEBjaGFpbmFibGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBvZiB0aGUgZXZlbnQgdG8gcmVtb3ZlICgxIHRvIDEgaHlwb3RoZXNpcylcbiAgICovXG4gIEV2ZW50UXVldWUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QpIHtcbiAgICAgIC8vIFNlYXJjaCBmb3IgdGhlIGluZGV4IG9mIHRoZSBvYmplY3QgaW4gdGhlIGxpc3QgKG5vdCB0aGUgZnVsbCBldmVudCBwYWlyKS5cbiAgICAgIHZhciBpbmRleCA9IHRoaXMuX19pbmRleE9mKG9iamVjdCk7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInJlbW92ZSgpOiBubyBvYmplY3RcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9fZXZlbnRMaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluYWJpbGl0eVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJyZW1vdmUoKTogbm8gb2JqZWN0XCIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIGFuIGV2ZW50IChhbiBvcmRlcmVkIHBhaXIgW29iamVjdCwgdmFsdWVdKSBpbnRvIHRoZSBldmVudCBsaXN0LlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgcmVmZXJlbmNlXG4gICAqIEBwYXJhbSB7RmxvYXR9IHZhbHVlIGZvciBzY2hlZHVsaW5nIG9yIHNlcXVlbmNpbmcsIGkuZS4gZWl0aGVyIHRpbWUgb3IgcG9zaXRpb24gdmFsdWVcbiAgICogQHRvZG8gT3B0aW1pemUgYWxnb3JpdGhtOiBhdCBsZWFzdCwgdGVzdCBpZiBtb3ZpbmcgaXMgbmVjZXNzYXJ5P1xuICAgKi9cbiAgRXZlbnRRdWV1ZS5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKG9iamVjdCwgdmFsdWUpIHtcbiAgICB0aGlzLnJlbW92ZShvYmplY3QpO1xuICAgIHRoaXMuaW5zZXJ0KG9iamVjdCwgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgdGhlIGZpcnN0IGV2ZW50IG9mIHRoZSBldmVudCBsaXN0IG9ubHkgaWYgbmVlZGVkLlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgcmVmZXJlbmNlXG4gICAqIEBwYXJhbSB7RmxvYXR9IHZhbHVlIGZvciBzY2hlZHVsaW5nIG9yIHNlcXVlbmNpbmcsIGllIGVpdGhlciB0aW1lIG9yIHBvc2l0aW9uIHZhbHVlXG4gICAqL1xuICBFdmVudFF1ZXVlLnByb3RvdHlwZS5tb3ZlRmlyc3RFdmVudCA9IGZ1bmN0aW9uKG9iamVjdCwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5fX2lzQmFja3dhcmQpIHtcbiAgICAgIGlmICh2YWx1ZSA+IHRoaXMuZ2V0VmFsdWVPZkluZGV4KDEpKSB7XG4gICAgICAgIHRoaXMuX19ldmVudExpc3RbMF1bMV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX19ldmVudExpc3Quc2hpZnQoKTtcbiAgICAgICAgdGhpcy5pbnNlcnQob2JqZWN0LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2YWx1ZSA8PSB0aGlzLmdldFZhbHVlT2ZJbmRleCgxKSkge1xuICAgICAgICB0aGlzLl9fZXZlbnRMaXN0WzBdWzFdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9fZXZlbnRMaXN0LnNoaWZ0KCk7XG4gICAgICAgIHRoaXMuaW5zZXJ0KG9iamVjdCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZmlyc3QgZXZlbnQgZnJvbSB0aGUgZXZlbnQgbGlzdC5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgRXZlbnRRdWV1ZS5wcm90b3R5cGUuZ2V0Rmlyc3RFdmVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9fZXZlbnRMaXN0WzBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBvYmplY3Qgb2YgZmlyc3QgZXZlbnQgZnJvbSB0aGUgZXZlbnQgbGlzdC5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgRXZlbnRRdWV1ZS5wcm90b3R5cGUuZ2V0Rmlyc3RPYmplY3QgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fX2V2ZW50TGlzdFswXVswXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdmFsdWUgb2YgZmlyc3QgZXZlbnQgZnJvbSB0aGUgZXZlbnQgbGlzdCAoZWl0aGVyIHRpbWUgb3IgcG9zaXRpb24pLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBFdmVudFF1ZXVlLnByb3RvdHlwZS5nZXRGaXJzdFZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX19ldmVudExpc3RbMF1bMV07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQgZnJvbSB0aGUgZXZlbnQgbGlzdCAoZWl0aGVyIHRpbWUgb3IgcG9zaXRpb24pLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBFdmVudFF1ZXVlLnByb3RvdHlwZS5nZXRWYWx1ZU9mSW5kZXggPSBmdW5jdGlvbihpbmRleCkge1xuICAgIGlmICh0aGlzLl9fZXZlbnRMaXN0W2luZGV4XSkge1xuICAgICAgcmV0dXJuIHRoaXMuX19ldmVudExpc3RbaW5kZXhdWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZsdXNoIHRoZSBldmVudCBsaXN0LlxuICAgKiBAcHVibGljXG4gICAqL1xuICBFdmVudFF1ZXVlLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX19ldmVudExpc3QgPSBbXTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFNvcnQgdGhlIHdob2xlIGV2ZW50IGxpc3QuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIEV2ZW50UXVldWUucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fX2lzQmFja3dhcmQpIHtcbiAgICAgIHRoaXMuX19ldmVudExpc3Quc29ydCh0aGlzLl9fcmV2ZXJzZUNvbXBhcmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9fZXZlbnRMaXN0LnNvcnQodGhpcy5fX2NvbXBhcmUpO1xuICAgIH1cbiAgfVxuXG47cmV0dXJuIEV2ZW50UXVldWU7fSkoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFF1ZXVlOyIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiZXZlbnQtcXVldWVcIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMC4yLjBcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIldBVkUgYXVkaW8gbGlicmFyeSBtb2R1bGUgZm9yIGFuIGV2ZW50IHF1ZXVlXCIsXG4gIFwibWFpblwiOiBcImluZGV4LmpzXCIsXG4gIFwiZXhwb3J0c1wiOiBcImNyZWF0ZUV2ZW50UXVldWVcIixcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcInRlc3RcIjogXCJlY2hvIFxcXCJFcnJvcjogbm8gdGVzdCBzcGVjaWZpZWRcXFwiICYmIGV4aXQgMVwiXG4gIH0sXG4gIFwiYXV0aG9yXCI6IFwiS2FyaW0gQmFya2F0aVwiLFxuICBcImF1dGhvcnNcIjogW1xuICAgIFwiS2FyaW0gQmFya2F0aVwiLFxuICAgIFwiTm9yYmVydCBTY2huZWxsXCIsXG4gICAgXCJWaWN0b3IgU2FpelwiXG4gIF0sXG4gIFwibGljZW5zZVwiOiBcIkJTRC0zLUNsYXVzZVwiLFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiaHR0cDovL2dpdGh1Yi5jb20vSXJjYW0tUm5EL2V2ZW50LXF1ZXVlLmdpdFwiXG4gIH0sXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIm1vZHVsZS1ib2lsZXJwbGF0ZVwiOiBcImdpdDovL2dpdGh1Yi5jb20vSXJjYW0tUm5EL21vZHVsZS1ib2lsZXJwbGF0ZS5naXQjbWFzdGVyXCIsXG4gICAgXCJmcy11dGlsc1wiIDogXCIwLjQuM1wiLFxuICAgIFwiYnJvd3NlcmlmeVwiOiBcIn40LjEuMlwiLFxuICAgIFwibW9jaGFcIjogXCJ+MS4xNy4xXCIsXG4gICAgXCJjaGFpXCI6IFwifjEuOS4wXCIsXG4gICAgXCJibGFua2V0XCI6IFwifjEuMS42XCIsXG4gICAgXCJndWxwXCI6IFwifjMuOC4yXCJcbiAgfVxufSIsIi8qIEdlbmVyYXRlZCBieSBlczYtdHJhbnNwaWxlciB2IDAuNy4xNC0yICovXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgV0FWRSBhdWRpbyBsaWJyYXJ5IGVsZW1lbnQ6IHRoZSBtYWluIGF1ZGlvIHNjaGVkdWxlciBvZiB0aGUgbGlicmFyeSxcbiAqIGFzIGEgc2luZ2xldG9uIGluIHRoZSBnbG9iYWwgdmFyaWFibGUgJ3dha28nLlxuICogQGF1dGhvciBLYXJpbS5CYXJrYXRpQGlyY2FtLmZyLCBOb3JiZXJ0LlNjaG5lbGxAaXJjYW0uZnIsIFZpY3Rvci5TYWl6QGlyY2FtLmZyXG4gKiBAdmVyc2lvbiA1LjEuMFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gRW5zdXJlIHRoZXJlIGlzIGEgZ2xvYmFsbHkgYXZhaWxhYmxlIFwiYXVkaW9Db250ZXh0XCIgaW5zdGFuY2Ugb2YgdGhlIHdlYiBhdWRpbyBBdWRpb0NvbnRleHQuXG53aW5kb3cuYXVkaW9Db250ZXh0ID0gd2luZG93LmF1ZGlvQ29udGV4dCB8fCBuZXcgQXVkaW9Db250ZXh0KCk7XG5cbnZhciBTY2hlZHVsZXIgPSByZXF1aXJlKFwiLi4vc2NoZWR1bGVyXCIpO1xuXG52YXIgTWFpblNjaGVkdWxlciA9IChmdW5jdGlvbigpe3ZhciBEUCQwID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG4gIGZ1bmN0aW9uIE1haW5TY2hlZHVsZXIoKSB7XG5cbiAgICB0aGlzLm5hbWUgPSBcIndha28uc2NoZWR1bGVyXCJcbiAgICAvLyBIb3cgZnJlcXVlbnRseSB0byBjYWxsIHNjaGVkdWxpbmcgZnVuY3Rpb24gKHNlYykuXG4gICAgdGhpcy5zY2hlZHVsaW5nUGVyaW9kID0gIDAuMDI1O1xuICAgIC8vIEhvdyBmYXIgYWhlYWQgdG8gc2NoZWR1bGUgZXZlbnRzIChzZWMpLCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIHNjaGVkdWxpbmdQZXJpb2QuXG4gICAgdGhpcy5zY2hlZHVsZUFoZWFkVGltZSA9IDAuMTsgXG4gICAgdGhpcy5zY2hlZHVsZXIgPSBuZXcgU2NoZWR1bGVyKCk7XG5cbiAgICB0aGlzLnRpbWVySUQgPSBudWxsO1xuXG4gICAgdGhpcy5zY2hlZHVsZXIuc2V0UGFyZW50KHRoaXMsIHRoaXMub25SdW5uaW5nU3RhdHVzQ2hhbmdlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfURQJDAoTWFpblNjaGVkdWxlciwgXCJwcm90b3R5cGVcIiwge1wiY29uZmlndXJhYmxlXCI6IGZhbHNlLCBcImVudW1lcmFibGVcIjogZmFsc2UsIFwid3JpdGFibGVcIjogZmFsc2V9KTtcblxuICAvKipcbiAgICogUmVhY3QgdG8gcnVubmluZyBzdGF0dXMgY2hhbmdlIG9mIHRoZSBtYWluIHNjaGVkdWxlciB0aHJvdWdoIHRoaXMgY2FsbGJhY2suXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNYWluU2NoZWR1bGVyLnByb3RvdHlwZS5vblJ1bm5pbmdTdGF0dXNDaGFuZ2UgPSBmdW5jdGlvbihib29sKSB7XG4gICAgY29uc29sZS5sb2coXCJvblJ1bm5pbmdTdGF0dXNDaGFuZ2UgKG1haW5TY2hlZHVsZXIpXCIsIGJvb2wpO1xuICAgIGlmIChib29sKSB7XG4gICAgICB0aGlzLnBhcmVudC5zdGFydCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhcmVudC5zdG9wKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvYXJzZS1ncmFpbmVkIHNjaGVkdWxpbmcgb2YgYXVkaW8gZXZlbnRzLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBNYWluU2NoZWR1bGVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGF0ID0gdGhpczsgLy8gZm9yIHRoZSBzZXRUaW1lb3V0IGNsb3N1cmUsIGZhc3RlciB0aGFuIGEgYmluZCgpXG4gICAgdmFyIG5leHRFdmVudFRpbWUgPSBJbmZpbml0eTtcblxuICAgIC8vIFdoaWxlIHRoZXJlIGFyZSBldmVudHMgdGhhdCB3aWxsIG5lZWQgdG8gYmUgcGxheWVkIGJlZm9yZSB0aGUgbmV4dCBpbnRlcnZhbCwgXG4gICAgLy8gc2NoZWR1bGUgdGhlbSBhbmQgYWR2YW5jZSB0aGUgdGltZSBwb2ludGVyLlxuICAgIG5leHRFdmVudFRpbWUgPSB0aGlzLnNjaGVkdWxlci5nZXROZXh0VGltZSgpO1xuICAgIHdoaWxlIChuZXh0RXZlbnRUaW1lIDw9IGF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIHRoaXMuc2NoZWR1bGVBaGVhZFRpbWUpIHtcbiAgICAgIC8vIG5leHRFdmVudFRpbWUgPSB0aGlzLnNjaGVkdWxlci5tYWtlRXZlbnRBbmRSZXR1cm5OZXh0VGltZSgpO1xuICAgICAgdGhpcy5zY2hlZHVsZXIubWFrZU5leHRFdmVudCgpO1xuICAgICAgbmV4dEV2ZW50VGltZSA9IHRoaXMuc2NoZWR1bGVyLmdldE5leHRUaW1lKCk7XG4gICAgfVxuICAgIC8vIFN0b3JlIHRoZSBzZXRUaW1lb3V0IElEIHRvIGFsbG93IHJlbW92aW5nLlxuICAgIHRoaXMudGltZXJJRCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICB0aGF0LnN0YXJ0KCk7XG4gICAgfSwgdGhhdC5zY2hlZHVsaW5nUGVyaW9kICogMTAwMCk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCB0aGUgc2NoZWR1bGluZyBsb29wLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBNYWluU2NoZWR1bGVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJJRCk7XG4gIH1cblxuICAvKipcbiAgICogRm9yd2FyZCB0aGUgYWRkKCkgbWV0aG9kIHRvIHRoZSBpbnRlcm5hbCBzY2hlZHVsZXIuXG4gICAqIEBwdWJsaWNcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgTWFpblNjaGVkdWxlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdGhpcy5zY2hlZHVsZXIuYWRkKG9iamVjdCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRm9yd2FyZCB0aGUgcmVtb3ZlKCkgbWV0aG9kIHRvIHRoZSBpbnRlcm5hbCBzY2hlZHVsZXIuXG4gICAqIEBwdWJsaWNcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgTWFpblNjaGVkdWxlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdGhpcy5zY2hlZHVsZXIucmVtb3ZlKG9iamVjdCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHNjaGVkdWxpbmcgcGVyaW9kLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBNYWluU2NoZWR1bGVyLnByb3RvdHlwZS5nZXRTY2hlZHVsaW5nUGVyaW9kID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NoZWR1bGluZ1BlcmlvZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCB0aW1lIGZyb20gdGhlIFdlYiBBdWRpbyBjb250ZXh0LlxuICAgKiBAcHVibGljXG4gICAqL1xuICBNYWluU2NoZWR1bGVyLnByb3RvdHlwZS5nZXRDdXJyZW50VGltZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhdWRpb0NvbnRleHQuY3VycmVudFRpbWU7XG4gIH1cblxuO3JldHVybiBNYWluU2NoZWR1bGVyO30pKCk7XG5cbi8vIEVuc3VyZSB0aGVyZSBpcyBhIGdsb2JhbGx5IGF2YWlsYWJsZSBcIndha29cIiBpbnN0YW5jZSBvZiB0aGUgV0FWRSdzIGdsb2JhbCBuYW1lLXNwYWNlLlxud2luZG93Lndha28gPSB3aW5kb3cud2FrbyB8fCB7fTtcblxuLy8gUHJvdmlkZSB3YWtvIHdpdGggYSBNYWluU2NoZWR1bGVyIHNpbmdsZXRvbiwgb25seSBpZiBub3QgYWxyZWFkeSB0aGVyZS5cbndha28uc2NoZWR1bGVyID0gd2Frby5zY2hlZHVsZXIgfHwgbmV3IE1haW5TY2hlZHVsZXIoKTsiLCIvKiBHZW5lcmF0ZWQgYnkgZXM2LXRyYW5zcGlsZXIgdiAwLjcuMTQtMiAqL1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFdBVkUgYXVkaW8gbGlicmFyeSBlbGVtZW50OiBhIHdlYiBhdWRpbyBzY2hlZHVsZXIsIHdpdGhvdXQgdGltZSBsb29wLlxuICogQGF1dGhvciBLYXJpbS5CYXJrYXRpQGlyY2FtLmZyLCBOb3JiZXJ0LlNjaG5lbGxAaXJjYW0uZnIsIFZpY3Rvci5TYWl6QGlyY2FtLmZyXG4gKiBAdmVyc2lvbiA0LjEuMFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50UXVldWUgPSByZXF1aXJlKFwiLi4vZXZlbnQtcXVldWVcIik7XG5cbi8vIE1ha2UgYSBnbG9iYWwgaW5zdGFuY2Ugb2YgdGhlIHdha28uc2NoZWR1bGVyIGF2YWlsYWJsZVxucmVxdWlyZShcIi4uL21haW4tc2NoZWR1bGVyXCIpO1xuXG52YXIgU2NoZWR1bGVyID0gKGZ1bmN0aW9uKCl7dmFyIERQJDAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbiAgZnVuY3Rpb24gU2NoZWR1bGVyKG9wdE5hbWUpIHtcblxuICAgIGlmICghdGhpcyB8fCB0aGlzID09PSB3aW5kb3cpXG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJZb3Ugc2VlbSB0byBoYXZlIGZvcmdvdHRlbiB0aGUgbmV3IG9wZXJhdG9yOyBTaGFtZSBvbiB5b3UhXCIpO1xuXG4gICAgdGhpcy5uYW1lID0gb3B0TmFtZSB8fCBcIlNjaGVkdWxlclwiO1xuICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7ICAgIFxuICAgIHRoaXMuZXZlbnRRdWV1ZSA9IG51bGw7XG4gICAgdGhpcy5uZXh0RXZlbnRUaW1lID0gSW5maW5pdHlcbiAgICB0aGlzLnNjaGVkdWxhYmxlc0xpc3QgPSBbXVxuICAgIHRoaXMucGFyZW50ID0gbnVsbFxuICAgIC8vIHJlcXVpcmVkIG1ldGhvZCwgZnJvbSB0aGUgcGFyZW50XG4gICAgdGhpcy5ydW5uaW5nU3RhdHVzQ2hhbmdlQ2FsbGJhY2sgPSBudWxsO1xuICAgIHRoaXMuZXZlbnRRdWV1ZSA9IG5ldyBFdmVudFF1ZXVlKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfURQJDAoU2NoZWR1bGVyLCBcInByb3RvdHlwZVwiLCB7XCJjb25maWd1cmFibGVcIjogZmFsc2UsIFwiZW51bWVyYWJsZVwiOiBmYWxzZSwgXCJ3cml0YWJsZVwiOiBmYWxzZX0pO1xuXG4gIC8qKlxuICAgKiBTY2hlZHVsZSBhIHNjaGVkdWxhYmxlIG9iamVjdCBhbmQgYWRkIGl0IHRvIHRoZSBzY2hlZHVsaW5nIGxpc3QuXG4gICAqIEBwdWJsaWNcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgU2NoZWR1bGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBcbiAgICBvYmplY3Quc2NoZWR1bGVyID0gdGhpcztcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5zY2hlZHVsYWJsZXNMaXN0LnB1c2gob2JqZWN0KTtcbiAgICB2YXIgaW5kZXggPSBsZW5ndGggLSAxO1xuICAgIHZhciBuYW1lID0gb2JqZWN0Lm5hbWUgPyBvYmplY3QubmFtZSA6IG9iamVjdC5zY2hlZHVsaW5nSUQ7XG4gICAgY29uc29sZS5sb2coXCJhZGQoKTpcIiwgdGhpcy5uYW1lLCBcInNjaGVkdWxpbmcgZWxlbWVudCAjXCIgKyBpbmRleCArICcgXFxcIicgKyBuYW1lICsgJ1xcXCInKTtcbiAgICBpZiAoIXRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICAvLyB0aGlzLnJlc2V0QWxsKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFVuc2NoZWR1bGUgYSBzY2hlZHVsYWJsZSBvYmplY3QgYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSBzY2hlZHVsaW5nIGxpc3QuXG4gICAqIEBwdWJsaWNcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgU2NoZWR1bGVyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAvLyBTZWFyY2ggZm9yIHRoZSBvYmplY3QgaW4gdGhlIHNjaGVkdWxpbmcgbGlzdC5cbiAgICB2YXIgaW5kZXggPSB0aGlzLnNjaGVkdWxhYmxlc0xpc3QuaW5kZXhPZihvYmplY3QpO1xuXG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVtb3ZlKCk6IG9iamVjdCBub3QgZm91bmQsXCIgKyBvYmplY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNjaGVkdWxhYmxlc0xpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiVW5zY2hlZHVsaW5nIGVsZW1lbnQgI1wiICsgaW5kZXgsIG9iamVjdC5uYW1lID8gJ1xcXCInICsgb2JqZWN0Lm5hbWUgKyAnXFxcIicgOiBcIlwiLCBvYmplY3Quc2NoZWR1bGluZ0lEKTtcbiAgICAgIC8vIFdoZW4gdGhlIHNjaGVkdWxpbmcgbGlzdCBpcyBlbXB0eSwgc3RvcCBzY2hlZHVsaW5nLlxuICAgICAgaWYgKHRoaXMuc2NoZWR1bGFibGVzTGlzdC5sZW5ndGggPD0gMCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgc2NoZWR1bGluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFNjaGVkdWxlci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG4gICAgICBjb25zb2xlLmxvZyhcIlNjaGVkdWxpbmcgb25cIiwgXCIoXCIgKyB0aGlzLm5hbWUgKyBcIilcIik7XG4gICAgICB0aGlzLnJ1bm5pbmdTdGF0dXNDaGFuZ2VDYWxsYmFjayh0aGlzLmlzUnVubmluZyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3Agc2NoZWR1bGluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFNjaGVkdWxlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG4gICAgY29uc29sZS5sb2coXCJTY2hlZHVsaW5nIG9mZiAoXCIgKyB0aGlzLm5hbWUgKyBcIilcIik7XG4gICAgdGhpcy5ydW5uaW5nU3RhdHVzQ2hhbmdlQ2FsbGJhY2sodGhpcy5pc1J1bm5pbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IGFsbCBzY2hlZHVsYWJsZXMgb2JqZWN0cyBvZiB0aGlzIHNjaGVkdWxlci5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgU2NoZWR1bGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZXZlbnRRdWV1ZS5mbHVzaCgpO1xuICAgIHRoaXMuaW5zZXJ0QWxsKCk7XG4gIH1cblxuICAvKipcbiAgICogUHVzaCBhbGwgZXZlbnRzIGludG8gdGhlIGV2ZW50IHF1ZXVlIGFuZCBzb3J0IGl0IGFmdGVyd2FyZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFNjaGVkdWxlci5wcm90b3R5cGUuaW5zZXJ0QWxsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRpbWUgPSBudWxsO1xuICAgIHZhciBlbGVtZW50ID0gbnVsbDtcbiAgICAvLyBjb25zb2xlLmxvZyhcInNjaGVkdWxhYmxlc0xpc3Q6IFwiLCB0aGlzLnNjaGVkdWxhYmxlc0xpc3QpO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLnNjaGVkdWxhYmxlc0xpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGVsZW1lbnQgPSB0aGlzLnNjaGVkdWxhYmxlc0xpc3RbaV07XG4gICAgICB0aW1lID0gZWxlbWVudC5yZXNldEFuZFJldHVybk5leHRUaW1lKHRoaXMuZ2V0Q3VycmVudFRpbWUoKSk7XG4gICAgICB0aGlzLmV2ZW50UXVldWUucHVzaEV2ZW50KGVsZW1lbnQsIHRpbWUpO1xuICAgIH1cbiAgICB0aGlzLmV2ZW50UXVldWUuc29ydCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydCBhbiBldmVudCBpbnRvIHRoZSBldmVudCBxdWV1ZS5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgU2NoZWR1bGVyLnByb3RvdHlwZS5pbnNlcnRFdmVudCA9IGZ1bmN0aW9uKG9iamVjdCwgdGltZSkge1xuICAgIGlmICh0aW1lICE9PSBJbmZpbml0eSkge1xuICAgICAgdGhpcy5ldmVudFF1ZXVlLkluc2VydChvYmplY3QsIHRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCB0aW1lIGZyb20gd2Frby5zY2hlZHVsZXIuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIFNjaGVkdWxlci5wcm90b3R5cGUuZ2V0Q3VycmVudFRpbWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gd2Frby5zY2hlZHVsZXIuZ2V0Q3VycmVudFRpbWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgbmV4dCBzY2hlZHVsaW5nIHRpbWUgb2YgYSBzY2hlZHVsZWQgb2JqZWN0LlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHJlZmVyZW5jZVxuICAgKiBAcGFyYW0ge0Zsb2F0fSBuZXcgc2NoZWR1bGluZyB0aW1lIG9mIGl0cyBuZXh0IGV2ZW50OyBcIkluZmluaXR5XCIgbWVhbnMgXCJyZW1vdmUgZnJvbSBzY2hlZHVsaW5nXCJcbiAgICovXG4gIFNjaGVkdWxlci5wcm90b3R5cGUudXBkYXRlTmV4dFRpbWUgPSBmdW5jdGlvbihvYmplY3QsIHRpbWUpIHtcbiAgICBpZiAodGltZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgIHRoaXMuZXZlbnRRdWV1ZS5yZW1vdmUob2JqZWN0KTtcbiAgICAgIC8vIElmIHRoZSBxdWV1ZSBpcyBlbXB0eSwgc3RvcCBzY2hlZHVsaW5nLlxuICAgICAgaWYgKHRoaXMuZXZlbnRRdWV1ZS5sZW5ndGggPD0gMCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuZXZlbnRRdWV1ZS5pbmRleE9mKG9iamVjdCkgPCAwKSB7XG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZS5pbnNlcnQob2JqZWN0LCB0aW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZS5tb3ZlKG9iamVjdCwgdGltZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCBwYXJlbnQgYW5kIHN0YXR1cyBjaGFuZ2UgY2FsbGJhY2suXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnQgVGhlIHBhcmVudCBvZiBhIHNjaGVkdWxlciBoYXMgdG8gYmUgc2V0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGlzIHJlcXVpcmVkIGNhbGxiYWNrIHRyaWdnZXJzIHRoZSBwYXJlbnQsXG4gICAqIHdpdGggYSBib29sZWFuIG9uIHJ1bm5pbmcgc3RhdHVzIGNoYW5nZS5cbiAgICovXG4gIFNjaGVkdWxlci5wcm90b3R5cGUuc2V0UGFyZW50ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHRoaXMucGFyZW50ID0gb2JqZWN0O1xuICAgIHRoaXMucnVubmluZ1N0YXR1c0NoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cblxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vLyBUcmFuc3BvcnRpbmcgbWV0aG9kcyAvLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAvKipcbiAgICogQ2FsbCB0aGUgZXZlbnQgbWFraW5nIG1ldGhvZCBvZiB0aGUgZmlyc3Qgc2NoZWR1bGFibGUgb2JqZWN0LFxuICAgKiBhbmQgdGhlbiB1cGRhdGUgdGhlIGZpcnN0IGV2ZW50IG9mIHRoZSBxdWV1ZS5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgU2NoZWR1bGVyLnByb3RvdHlwZS5tYWtlTmV4dEV2ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGVuZ2luZSA9IHRoaXMuZXZlbnRRdWV1ZS5nZXRGaXJzdE9iamVjdCgpO1xuICAgIHRoaXMubmV4dEV2ZW50VGltZSA9IGVuZ2luZS5tYWtlRXZlbnRBbmRSZXR1cm5OZXh0VGltZSgpO1xuICAgIHRoaXMuZXZlbnRRdWV1ZS5tb3ZlRmlyc3RFdmVudChlbmdpbmUsIHRoaXMubmV4dEV2ZW50VGltZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IG5leHQgZXZlbnQgdGltZSBieSBxdWVyeWluZyBpdCBpbiB0aGUgZXZlbnQgcXVldWUuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIFNjaGVkdWxlci5wcm90b3R5cGUuZ2V0TmV4dFRpbWUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5zY2hlZHVsYWJsZXNMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMubmV4dEV2ZW50VGltZSA9IHRoaXMuZXZlbnRRdWV1ZS5nZXRGaXJzdFZhbHVlKCk7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0RXZlbnRUaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICB9XG5cbjtyZXR1cm4gU2NoZWR1bGVyO30pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZWR1bGVyOyJdfQ==
